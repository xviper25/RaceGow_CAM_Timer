<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Racegow FPV Lap Timer</title>
    <style>
        :root {
            --primary-color: #007bff;
            --secondary-color: #6c757d;
            --background-color: #f0f2f5;
            --surface-color: #ffffff;
            --text-color: #333;
            --success-color: #28a745;
            --warning-color: #ffc107;
            --danger-color: #dc3545;
            --font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            --line-visual-thickness: 10px; /* Visual thickness of draggable lines in CSS pixels */
            --line-touch-target-thickness: 20px; /* Larger invisible touch target for lines */
            --line-color-idle: rgba(220, 53, 69, 0.5); /* Reddish, semi-transparent */
            --line-color-active: rgba(220, 53, 69, 0.8);
        }

        body {
            font-family: var(--font-family);
            margin: 0;
            padding: 0;
            background-color: var(--background-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            overscroll-behavior: none; 
        }

        .container {
            width: 100%;
            max-width: 600px;
            padding: 15px;
            box-sizing: border-box;
        }

        header {
            background-color: var(--primary-color);
            color: white;
            padding: 15px;
            text-align: center;
            font-size: 1.5em;
            font-weight: bold;
            width: 100%;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 15px;
        }
        header h1 {
            margin: 0;
            font-size: 1.2em;
        }

        .video-container {
            position: relative;
            width: 100%;
            background-color: #000;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            user-select: none; /* Prevent text selection during drag */
            -webkit-user-select: none;
            -ms-user-select: none;

        }

        #videoFeed {
            width: 100%;
            display: block;
            transform: scaleX(-1);
        }

        #detectionCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%; /* Will be set by JS to match videoContainer */
            height: 100%;/* Will be set by JS to match videoContainer */
            pointer-events: none;
        }

        .boundary-line {
            position: absolute;
            background-color: var(--line-color-idle); /* Visible part */
            z-index: 5;
            touch-action: none;
            box-sizing: border-box;
        }
        /* Visual part of the line */
        .boundary-line::before {
            content: '';
            position: absolute;
            background-color: var(--line-color-idle);
        }
        /* Touch target (larger than visual part) */
        #lineTop, #lineBottom {
            height: var(--line-touch-target-thickness);
            cursor: ns-resize;
        }
        #lineTop::before, #lineBottom::before {
            height: var(--line-visual-thickness);
            width: 100%;
            top: 50%;
            transform: translateY(-50%);
        }
        
        #lineLeft, #lineRight {
            width: var(--line-touch-target-thickness);
            cursor: ew-resize;
        }
         #lineLeft::before, #lineRight::before {
            width: var(--line-visual-thickness);
            height: 100%;
            left: 50%;
            transform: translateX(-50%);
        }
        /* Change color of visual part when active */
        .boundary-line.active::before {
            background-color: var(--line-color-active);
        }


        .controls, .session-controls, .stats-display, .lap-list-container {
            background-color: var(--surface-color);
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .controls h2, .session-controls h2, .stats-display h2, .lap-list-container h2 {
            margin-top: 0;
            font-size: 1.2em;
            color: var(--primary-color);
            border-bottom: 1px solid #eee;
            padding-bottom: 8px;
        }

        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 10px 15px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.2s ease;
        }
        button:hover:not(:disabled) {
            background-color: #0056b3;
        }
        button:disabled {
            background-color: var(--secondary-color);
            cursor: not-allowed;
        }
        .btn-success { background-color: var(--success-color); }
        .btn-success:hover:not(:disabled) { background-color: #1e7e34; }
        .btn-warning { background-color: var(--warning-color); color: #333; }
        .btn-warning:hover:not(:disabled) { background-color: #d39e00; }
        .btn-danger { background-color: var(--danger-color); }
        .btn-danger:hover:not(:disabled) { background-color: #bd2130; }


        input[type="text"], input[type="range"] {
            padding: 8px;
            margin: 5px 0;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box;
            width: calc(100% - 10px);
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        .slider-container label {
            margin-right: 10px;
            white-space: nowrap;
        }
        .slider-container input[type="range"] {
            flex-grow: 1;
        }
        .slider-container span {
            min-width: 30px;
            text-align: right;
        }

        #lapTimesList {
            list-style-type: none;
            padding: 0;
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #eee;
            border-radius: 4px;
        }
        #lapTimesList li {
            padding: 8px 10px;
            border-bottom: 1px solid #eee;
        }
        #lapTimesList li:last-child {
            border-bottom: none;
        }
        #lapTimesList li.best-lap {
            background-color: #e6ffed;
            font-weight: bold;
        }

        .status-message {
            padding: 10px;
            margin-bottom: 15px;
            border-radius: 5px;
            text-align: center;
        }
        .status-info { background-color: #e7f3fe; color: #0c5460; border: 1px solid #b8daff;}
        .status-error { background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6cb;}
        .status-warning { background-color: #fff3cd; color: #856404; border: 1px solid #ffeeba; }

        .flex-controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-around;
        }
        .flex-controls button {
            flex-grow: 1;
            margin: 5px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            text-align: center;
        }
        .stat-item {
            background-color: #f9f9f9;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #eee;
        }
        .stat-item .label {
            font-size: 0.8em;
            color: var(--secondary-color);
            display: block;
            margin-bottom: 5px;
        }
        .stat-item .value {
            font-size: 1.4em;
            font-weight: bold;
            color: var(--primary-color);
        }
        .stat-item .value.small {
            font-size: 1em;
        }

        #instructionOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
            font-size: 1.2em;
            z-index: 10;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <header>
        <h1>Racegow FPV Lap Timer</h1>
    </header>

    <div class="container">
        <div id="statusMessage" class="status-message status-info">Initializing...</div>

        <div class="video-container">
            <video id="videoFeed" playsinline autoplay muted></video>
            <canvas id="detectionCanvas"></canvas>
            <div class="boundary-line" id="lineTop"></div>
            <div class="boundary-line" id="lineBottom"></div>
            <div class="boundary-line" id="lineLeft"></div>
            <div class="boundary-line" id="lineRight"></div>
            <div id="instructionOverlay" style="display: none;">Adjust boundary lines to set detection zone.</div>
        </div>

        <div class="controls">
            <h2>Timer Controls</h2>
            <div class="flex-controls">
                <button id="startTimerBtn" class="btn-success" disabled>Start Timer</button>
                <button id="stopTimerBtn" disabled class="btn-danger">Stop Timer</button>
                <button id="resetTimerBtn" class="btn-warning">Reset All</button>
            </div>
            <div class="slider-container">
                <label for="sensitivityRange">Sensitivity:</label>
                <input type="range" id="sensitivityRange" min="5" max="50" value="20">
                <span id="sensitivityValue">20</span>
            </div>
            <div class="slider-container">
                <label for="minLapTimeRange">Min Lap (s):</label>
                <input type="range" id="minLapTimeRange" min="0.5" max="5" step="0.1" value="1.0">
                <span id="minLapTimeValue">1.0</span>
            </div>
        </div>
        
        <div class="stats-display">
            <h2>Live Stats</h2>
            <div class="stats-grid">
                <div class="stat-item">
                    <span class="label">Current Lap</span>
                    <span class="value" id="lapCount">0</span>
                </div>
                <div class="stat-item">
                    <span class="label">Last Lap</span>
                    <span class="value" id="lastLapTime">0.000s</span>
                </div>
                <div class="stat-item">
                    <span class="label">Best Lap</span>
                    <span class="value" id="bestLapTime">N/A</span>
                </div>
            </div>
             <div class="stat-item" style="margin-top:10px;">
                <span class="label">Best 3 Consecutive</span>
                <span class="value small" id="best3Consecutive">-</span>
            </div>
            <div class="stat-item">
                <span class="label">Total Time</span>
                <span class="value" id="totalTime">0.000s</span>
            </div>
        </div>

        <div class="lap-list-container">
            <h2>Lap Times</h2>
            <ul id="lapTimesList"></ul>
        </div>

        <div class="session-controls">
            <h2>Session Management</h2>
            <input type="text" id="sessionName" placeholder="Enter session name (e.g., Track A - Evening)">
            <button id="saveSessionBtn">Save Laps</button>
            <button id="loadSessionBtn">Load Last Session</button>
            <p style="font-size: 0.8em; color: var(--secondary-color);">Sessions are saved in your browser's cookies.</p>
        </div>
    </div>

    <script>
        const video = document.getElementById('videoFeed');
        const videoContainer = document.querySelector('.video-container');
        const canvasEl = document.getElementById('detectionCanvas'); // Renamed to avoid conflict with canvas global
        const ctx = canvasEl.getContext('2d', { willReadFrequently: true });
        const instructionOverlay = document.getElementById('instructionOverlay');

        const lineTop = document.getElementById('lineTop');
        const lineBottom = document.getElementById('lineBottom');
        const lineLeft = document.getElementById('lineLeft');
        const lineRight = document.getElementById('lineRight');
        const boundaryLineElements = [lineTop, lineBottom, lineLeft, lineRight];

        const startTimerBtn = document.getElementById('startTimerBtn');
        const stopTimerBtn = document.getElementById('stopTimerBtn');
        // ... (other element getters are fine)
        const lapCountDisplay = document.getElementById('lapCount');
        const lastLapTimeDisplay = document.getElementById('lastLapTime');
        const bestLapTimeDisplay = document.getElementById('bestLapTime');
        const totalTimeDisplay = document.getElementById('totalTime');
        const best3ConsecutiveDisplay = document.getElementById('best3Consecutive');
        const lapTimesList = document.getElementById('lapTimesList');
        const sessionNameInput = document.getElementById('sessionName');
        const saveSessionBtn = document.getElementById('saveSessionBtn');
        const loadSessionBtn = document.getElementById('loadSessionBtn');
        const statusMessage = document.getElementById('statusMessage');
        const sensitivityRange = document.getElementById('sensitivityRange');
        const sensitivityValue = document.getElementById('sensitivityValue');
        const minLapTimeRange = document.getElementById('minLapTimeRange');
        const minLapTimeValue = document.getElementById('minLapTimeValue');


        let stream;
        let detectionZone = null; 
        let activeLine = null;
        let initialPointerViewportX, initialPointerViewportY;
        let initialZoneState = {}; // To store zone state at drag start

        let timerRunning = false;
        let lapStartTime = 0;
        let currentLap = 0;
        let lapTimes = [];
        let lastTriggerTime = 0;
        let animationFrameId;
        let prevImageData = null;
        let totalStartTime = 0;

        const MOTION_THRESHOLD_BASE = 20;
        let MIN_LAP_TIME_MS = 1000;
        const MIN_ZONE_DIMENSION_CANVAS = 20; // Minimum width/height for detection zone in canvas pixels
        const LINE_VISUAL_THICKNESS_CSS = 10; // Matches --line-visual-thickness in CSS
        const LINE_TOUCH_TARGET_THICKNESS_CSS = 20; // Matches --line-touch-target-thickness


        async function init() {
            try {
                statusMessage.textContent = "Requesting camera access...";
                statusMessage.className = "status-message status-info";
                stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' } });
                video.srcObject = stream;
                await video.play();

                video.onloadedmetadata = () => {
                    // Set canvas internal resolution to video's native resolution
                    canvasEl.width = video.videoWidth;
                    canvasEl.height = video.videoHeight;

                    // Set canvas display size to match video container's display size
                    // This is important if videoContainer is scaled responsively
                    canvasEl.style.width = videoContainer.offsetWidth + 'px';
                    canvasEl.style.height = videoContainer.offsetHeight + 'px';
                    
                    loadDetectionZoneFromCookie(); 
                    if (!detectionZone || !isValidZone(detectionZone)) { 
                        const inset = 0.20; // 20% inset
                        detectionZone = {
                            x: canvasEl.width * inset,
                            y: canvasEl.height * inset,
                            width: canvasEl.width * (1 - 2 * inset),
                            height: canvasEl.height * (1 - 2 * inset)
                        };
                    }
                    
                    initializeBoundaryLineInteractions();
                    positionLinesFromZone(); 
                    drawDetectionZone(); 
                    
                    statusMessage.textContent = "Camera active. Adjust zone if needed, then start.";
                    statusMessage.className = "status-message status-info";
                    startTimerBtn.disabled = false; // Enable start button now
                    instructionOverlay.style.display = 'flex';
                    setTimeout(() => {
                        if (instructionOverlay.style.display !== 'none') { // Only hide if not interacted with
                           instructionOverlay.style.display = 'none';
                        }
                    }, 3000);
                };

                video.onerror = (e) => {
                    console.error("Video error:", e);
                    statusMessage.textContent = "Video error. Check camera permissions or try another browser.";
                    statusMessage.className = "status-message status-error";
                    startTimerBtn.disabled = true;
                };

            } catch (err) {
                console.error("Error accessing camera:", err);
                statusMessage.textContent = `Error: ${err.name}. Ensure camera access is allowed. Try refreshing.`;
                statusMessage.className = "status-message status-error";
                startTimerBtn.disabled = true;
            }
        }

        function isValidZone(zone) {
            return zone &&
                   typeof zone.x === 'number' && typeof zone.y === 'number' &&
                   typeof zone.width === 'number' && zone.width >= MIN_ZONE_DIMENSION_CANVAS &&
                   typeof zone.height === 'number' && zone.height >= MIN_ZONE_DIMENSION_CANVAS;
        }

        function initializeBoundaryLineInteractions() {
            boundaryLineElements.forEach(line => {
                line.addEventListener('mousedown', handlePointerDown);
                line.addEventListener('touchstart', handlePointerDown, { passive: false });
            });
            // Add move and end listeners to document to catch drags outside videoContainer
            document.addEventListener('mousemove', handlePointerMove);
            document.addEventListener('touchmove', handlePointerMove, { passive: false });
            
            document.addEventListener('mouseup', handlePointerUp);
            document.addEventListener('touchend', handlePointerUp);
            document.addEventListener('touchcancel', handlePointerUp);
        }
        
        function handlePointerDown(event) {
            if (timerRunning) return;
            if (event.type === 'touchstart') event.preventDefault(); // Prevent scrolling only for touch

            activeLine = event.target.closest('.boundary-line'); // Ensure we get the line div
            if (!activeLine) return;
            
            activeLine.classList.add('active');

            initialPointerViewportX = (event.type === 'touchstart') ? event.touches[0].clientX : event.clientX;
            initialPointerViewportY = (event.type === 'touchstart') ? event.touches[0].clientY : event.clientY;
            initialZoneState = { ...detectionZone }; // Shallow copy
            
            instructionOverlay.style.display = 'none'; // Hide overlay on interaction
        }

        function handlePointerMove(event) {
            if (!activeLine || timerRunning) return;
            if (event.type === 'touchmove') event.preventDefault();

            const currentPointerViewportX = (event.type === 'touchmove') ? event.touches[0].clientX : event.clientX;
            const currentPointerViewportY = (event.type === 'touchmove') ? event.touches[0].clientY : event.clientY;

            const deltaViewportX = currentPointerViewportX - initialPointerViewportX;
            const deltaViewportY = currentPointerViewportY - initialPointerViewportY;

            // Convert viewport deltas to canvas pixel deltas
            const videoRect = videoContainer.getBoundingClientRect(); // Get current display size
            const deltaCanvasX = deltaViewportX * (canvasEl.width / videoRect.width);
            const deltaCanvasY = deltaViewportY * (canvasEl.height / videoRect.height);
            
            let newX = initialZoneState.x;
            let newY = initialZoneState.y;
            let newWidth = initialZoneState.width;
            let newHeight = initialZoneState.height;

            if (activeLine === lineTop) {
                newY = initialZoneState.y + deltaCanvasY;
                newHeight = initialZoneState.height - deltaCanvasY;
            } else if (activeLine === lineBottom) {
                newHeight = initialZoneState.height + deltaCanvasY;
            } else if (activeLine === lineLeft) {
                newX = initialZoneState.x + deltaCanvasX;
                newWidth = initialZoneState.width - deltaCanvasX;
            } else if (activeLine === lineRight) {
                newWidth = initialZoneState.width + deltaCanvasX;
            }
            
            // Apply constraints
            // Ensure positive width/height first
            if (newWidth < MIN_ZONE_DIMENSION_CANVAS) {
                if (activeLine === lineLeft) newX = initialZoneState.x + initialZoneState.width - MIN_ZONE_DIMENSION_CANVAS;
                newWidth = MIN_ZONE_DIMENSION_CANVAS;
            }
            if (newHeight < MIN_ZONE_DIMENSION_CANVAS) {
                if (activeLine === lineTop) newY = initialZoneState.y + initialZoneState.height - MIN_ZONE_DIMENSION_CANVAS;
                newHeight = MIN_ZONE_DIMENSION_CANVAS;
            }

            // Boundary constraints (0 to canvasEl.width/height)
            newX = Math.max(0, Math.min(newX, canvasEl.width - newWidth));
            newY = Math.max(0, Math.min(newY, canvasEl.height - newHeight));
            // Re-check width/height after boundary adjustment if X/Y was clamped
            newWidth = Math.min(newWidth, canvasEl.width - newX);
            newHeight = Math.min(newHeight, canvasEl.height - newY);


            detectionZone.x = newX;
            detectionZone.y = newY;
            detectionZone.width = newWidth;
            detectionZone.height = newHeight;

            positionLinesFromZone();
            drawDetectionZone();
        }

        function handlePointerUp(event) {
            if (!activeLine || timerRunning) return;
            activeLine.classList.remove('active');
            activeLine = null;
            saveDetectionZoneToCookie();
            statusMessage.textContent = "Detection zone updated. Ready.";
            statusMessage.className = "status-message status-info";
        }
        
        function positionLinesFromZone() {
            if (!detectionZone || !lineTop || !videoContainer.offsetWidth) return; 

            const videoRect = videoContainer.getBoundingClientRect(); // Get current display dimensions
            const scaleX = (val) => (val / canvasEl.width) * videoRect.width;
            const scaleY = (val) => (val / canvasEl.height) * videoRect.height;

            // For horizontal lines (top, bottom), width is scaled detectionZone.width
            // Their left position is scaled detectionZone.x
            // Their top position is scaled detectionZone.y (for top) or (detectionZone.y + detectionZone.height) for bottom, adjusted by line thickness
            lineTop.style.left = scaleX(detectionZone.x) - (LINE_TOUCH_TARGET_THICKNESS_CSS / 2 - LINE_VISUAL_THICKNESS_CSS / 2) + 'px'; // Center visual part
            lineTop.style.top = scaleY(detectionZone.y) - (LINE_TOUCH_TARGET_THICKNESS_CSS / 2) + 'px';
            lineTop.style.width = scaleX(detectionZone.width) + (LINE_TOUCH_TARGET_THICKNESS_CSS - LINE_VISUAL_THICKNESS_CSS) + 'px';

            lineBottom.style.left = scaleX(detectionZone.x) - (LINE_TOUCH_TARGET_THICKNESS_CSS / 2 - LINE_VISUAL_THICKNESS_CSS / 2) + 'px';
            lineBottom.style.top = scaleY(detectionZone.y + detectionZone.height) - (LINE_TOUCH_TARGET_THICKNESS_CSS / 2) + 'px';
            lineBottom.style.width = scaleX(detectionZone.width) + (LINE_TOUCH_TARGET_THICKNESS_CSS - LINE_VISUAL_THICKNESS_CSS) + 'px';

            // For vertical lines (left, right), height is scaled detectionZone.height
            // Their top position is scaled detectionZone.y
            // Their left position is scaled detectionZone.x (for left) or (detectionZone.x + detectionZone.width) for right, adjusted by line thickness
            lineLeft.style.top = scaleY(detectionZone.y) - (LINE_TOUCH_TARGET_THICKNESS_CSS / 2 - LINE_VISUAL_THICKNESS_CSS / 2) + 'px';
            lineLeft.style.left = scaleX(detectionZone.x) - (LINE_TOUCH_TARGET_THICKNESS_CSS / 2) + 'px';
            lineLeft.style.height = scaleY(detectionZone.height) + (LINE_TOUCH_TARGET_THICKNESS_CSS - LINE_VISUAL_THICKNESS_CSS) + 'px';

            lineRight.style.top = scaleY(detectionZone.y) - (LINE_TOUCH_TARGET_THICKNESS_CSS / 2 - LINE_VISUAL_THICKNESS_CSS / 2) + 'px';
            lineRight.style.left = scaleX(detectionZone.x + detectionZone.width) - (LINE_TOUCH_TARGET_THICKNESS_CSS / 2) + 'px';
            lineRight.style.height = scaleY(detectionZone.height) + (LINE_TOUCH_TARGET_THICKNESS_CSS - LINE_VISUAL_THICKNESS_CSS) + 'px';
        }


        function drawDetectionZone() {
            // Scale canvas display size to match video container, if it changed (e.g. resize)
            if (canvasEl.style.width !== videoContainer.offsetWidth + 'px' || canvasEl.style.height !== videoContainer.offsetHeight + 'px') {
                canvasEl.style.width = videoContainer.offsetWidth + 'px';
                canvasEl.style.height = videoContainer.offsetHeight + 'px';
            }
            
            ctx.clearRect(0, 0, canvasEl.width, canvasEl.height); // Clear based on internal resolution
            if (detectionZone) {
                ctx.strokeStyle = 'rgba(0, 255, 0, 0.9)'; // Brighter green
                ctx.lineWidth = Math.max(2, 6 * (videoContainer.offsetWidth / canvasEl.width)); // Scaled line width
                ctx.strokeRect(detectionZone.x, detectionZone.y, detectionZone.width, detectionZone.height);
            }
        }

        // Resize observer to re-calculate line positions and canvas display if container size changes
        const resizeObserver = new ResizeObserver(entries => {
            for (let entry of entries) {
                if (entry.target === videoContainer) {
                    if (detectionZone) { // Only if zone exists
                        positionLinesFromZone();
                        drawDetectionZone();
                    }
                }
            }
        });
        resizeObserver.observe(videoContainer);


        // --- Motion Detection --- (Minor change for clarity in drawImage)
        function detectMotion() {
            if (!timerRunning || !detectionZone || !video.videoWidth || video.paused || video.ended) {
                if(timerRunning) animationFrameId = requestAnimationFrame(detectMotion);
                return;
            }
            // Ensure detectionZone dimensions are positive for offscreen canvas
            const zoneWidthForProcessing = Math.max(1, Math.floor(detectionZone.width));
            const zoneHeightForProcessing = Math.max(1, Math.floor(detectionZone.height));

            const offscreenCanvas = document.createElement('canvas');
            const offscreenCtx = offscreenCanvas.getContext('2d', { willReadFrequently: true });
            offscreenCanvas.width = zoneWidthForProcessing;
            offscreenCanvas.height = zoneHeightForProcessing;

            // Correct for mirrored video when sampling sourceX
            const sourceX = video.videoWidth - detectionZone.x - detectionZone.width;
            offscreenCtx.drawImage(video, 
                                   sourceX, detectionZone.y, // Source x, y from original video
                                   detectionZone.width, detectionZone.height, // Source width, height
                                   0, 0, // Destination x, y on offscreen canvas
                                   zoneWidthForProcessing, zoneHeightForProcessing); // Destination width, height
            
            const currentFrameData = offscreenCtx.getImageData(0, 0, zoneWidthForProcessing, zoneHeightForProcessing);
            
            if (prevImageData) {
                let diff = 0;
                for (let i = 0; i < currentFrameData.data.length; i += 4) {
                    diff += Math.abs(currentFrameData.data[i] - prevImageData.data[i]);
                    diff += Math.abs(currentFrameData.data[i+1] - prevImageData.data[i+1]);
                    diff += Math.abs(currentFrameData.data[i+2] - prevImageData.data[i+2]);
                }
                const avgDiff = diff / (currentFrameData.data.length / 4);
                const motionThreshold = MOTION_THRESHOLD_BASE * ( (55 - parseInt(sensitivityRange.value)) / 30 );

                if (avgDiff > motionThreshold) {
                    triggerLap();
                    // Visual feedback on main canvas (already scaled for display)
                    const displayRectX = (detectionZone.x / canvasEl.width) * videoContainer.offsetWidth;
                    const displayRectY = (detectionZone.y / canvasEl.height) * videoContainer.offsetHeight;
                    const displayRectWidth = (detectionZone.width / canvasEl.width) * videoContainer.offsetWidth;
                    const displayRectHeight = (detectionZone.height / canvasEl.height) * videoContainer.offsetHeight;
                    
                    // Draw on the main canvas (canvasEl) which is already scaled to display size
                    // We need to use its own 2D context (ctx) and scale the detectionZone coordinates
                    // to its internal resolution for drawing.
                    ctx.fillStyle = 'rgba(255, 255, 0, 0.4)'; // Yellow flash
                    ctx.fillRect(detectionZone.x, detectionZone.y, detectionZone.width, detectionZone.height);
                    setTimeout(() => drawDetectionZone(), 150); // Redraw normal zone after flash
                }
            }
            prevImageData = currentFrameData;
            if (timerRunning) animationFrameId = requestAnimationFrame(detectMotion); // Ensure timerRunning check
        }

        startTimerBtn.addEventListener('click', () => {
            if (!detectionZone || !isValidZone(detectionZone)) {
                statusMessage.textContent = "Please set a valid detection zone first!";
                statusMessage.className = "status-message status-warning";
                instructionOverlay.style.display = 'flex';
                return;
            }
            if (timerRunning) return;

            timerRunning = true;
            startTimerBtn.disabled = true;
            stopTimerBtn.disabled = false;
            resetTimerBtn.disabled = true;
            sensitivityRange.disabled = true;
            minLapTimeRange.disabled = true;
            // Disable line dragging (visual cue or actual pointer-events: none)
            boundaryLineElements.forEach(line => line.style.pointerEvents = 'none'); 

            lapStartTime = performance.now();
            if (currentLap === 0) {
                totalStartTime = lapStartTime;
            }
            lastTriggerTime = performance.now() - MIN_LAP_TIME_MS;
            
            statusMessage.textContent = "Timer started. Listening for motion...";
            statusMessage.className = "status-message status-success"; // More positive status
            
            prevImageData = null;
            animationFrameId = requestAnimationFrame(detectMotion); // Start loop
            updateTotalTimeDisplay();
        });

        stopTimerBtn.addEventListener('click', () => {
            if (!timerRunning) return;
            timerRunning = false;
            cancelAnimationFrame(animationFrameId);
            startTimerBtn.disabled = false;
            stopTimerBtn.disabled = true;
            resetTimerBtn.disabled = false;
            sensitivityRange.disabled = false;
            minLapTimeRange.disabled = false;
            boundaryLineElements.forEach(line => line.style.pointerEvents = 'auto');
            prevImageData = null;
            statusMessage.textContent = "Timer stopped. Adjust zone or start again.";
            statusMessage.className = "status-message status-info";
        });
        
        resetTimerBtn.addEventListener('click', () => {
            if (timerRunning) stopTimerBtn.click(); 
            currentLap = 0;
            lapTimes = [];
            lapStartTime = 0;
            totalStartTime = 0;
            prevImageData = null;
            updateLapDisplay();
            lapTimesList.innerHTML = '';
            bestLapTimeDisplay.textContent = "N/A";
            best3ConsecutiveDisplay.textContent = "-";
            totalTimeDisplay.textContent = "0.000s";
            lapCountDisplay.textContent = "0";
            lastLapTimeDisplay.textContent = "0.000s";
            sessionNameInput.value = '';
            
            const inset = 0.20;
            detectionZone = { // Reset to default
                x: canvasEl.width * inset,
                y: canvasEl.height * inset,
                width: canvasEl.width * (1 - 2 * inset),
                height: canvasEl.height * (1 - 2 * inset)
            };
            positionLinesFromZone();
            drawDetectionZone();
            saveDetectionZoneToCookie(); 

            statusMessage.textContent = "Timer reset. Adjust zone and start.";
            statusMessage.className = "status-message status-info";
            instructionOverlay.style.display = 'flex';
            setTimeout(() => instructionOverlay.style.display = 'none', 3000);
            startTimerBtn.disabled = false; // Re-enable start button
        });

        // --- Other functions (triggerLap, updateTotalTimeDisplay, updateLapDisplay, etc.) ---
        // These should be largely okay, but ensure they don't conflict with new variable names
        // or rely on old state. I'll keep them as they were unless a direct conflict.
        // (No changes needed to the functions below this line from the previous version,
        // just ensure variable names like `canvas` are updated to `canvasEl` if they were used there)

        function triggerLap() {
            const now = performance.now();
            if (now - lastTriggerTime < MIN_LAP_TIME_MS) {
                return;
            }
            lastTriggerTime = now;

            if (currentLap > 0 || lapTimes.length > 0) {
                 const lapTime = (now - lapStartTime) / 1000;
                 lapTimes.push(lapTime);
            } else if (currentLap === 0 && lapTimes.length === 0) {
                 totalStartTime = now;
            }
            currentLap++;
            lapStartTime = now;
            updateLapDisplay();
            speakLapTime();
        }

        function updateTotalTimeDisplay() {
            if (timerRunning) {
                const elapsed = (performance.now() - totalStartTime) / 1000;
                totalTimeDisplay.textContent = elapsed.toFixed(3) + 's';
                if(timerRunning) requestAnimationFrame(updateTotalTimeDisplay); // Check again
            } else if (lapTimes.length > 0) {
                 const sumOfLaps = lapTimes.reduce((sum, t) => sum + t, 0);
                 totalTimeDisplay.textContent = sumOfLaps.toFixed(3) + 's';
            } else {
                totalTimeDisplay.textContent = "0.000s";
            }
        }

        function updateLapDisplay() {
            lapCountDisplay.textContent = currentLap;
            if (lapTimes.length > 0) {
                const lastLap = lapTimes[lapTimes.length - 1];
                lastLapTimeDisplay.textContent = lastLap.toFixed(3) + 's';

                const li = document.createElement('li');
                li.textContent = `Lap ${lapTimes.length}: ${lastLap.toFixed(3)}s`;
                lapTimesList.prepend(li);

                updateBestLap();
                updateBest3Consecutive();
            } else {
                lastLapTimeDisplay.textContent = "0.000s";
            }
            updateTotalTimeDisplay();
        }

        function updateBestLap() {
            if (lapTimes.length === 0) {
                bestLapTimeDisplay.textContent = "N/A";
                return;
            }
            const best = Math.min(...lapTimes);
            bestLapTimeDisplay.textContent = best.toFixed(3) + 's';
            const lis = lapTimesList.getElementsByTagName('li');
            for (let li of lis) {
                li.classList.remove('best-lap');
                // Use a tolerance for float comparison
                if (Math.abs(parseFloat(li.textContent.split(': ')[1]) - best) < 0.0001) {
                    li.classList.add('best-lap');
                }
            }
        }

        function updateBest3Consecutive() {
            if (lapTimes.length < 3) {
                best3ConsecutiveDisplay.textContent = "-";
                return;
            }
            let minSum = Infinity;
            let bestStartIndex = -1;
            for (let i = 0; i <= lapTimes.length - 3; i++) {
                const currentSum = lapTimes[i] + lapTimes[i+1] + lapTimes[i+2];
                if (currentSum < minSum) {
                    minSum = currentSum;
                    bestStartIndex = i;
                }
            }
            if (bestStartIndex !== -1) {
                const laps = lapTimes.slice(bestStartIndex, bestStartIndex + 3);
                best3ConsecutiveDisplay.textContent = 
                    `Laps ${bestStartIndex + 1}-${bestStartIndex + 3}: ${minSum.toFixed(3)}s ` +
                    `(${laps.map(t => t.toFixed(2)).join(', ')})`;
            } else {
                 best3ConsecutiveDisplay.textContent = "-";
            }
        }

        function speakLapTime() {
            if (lapTimes.length > 0 && 'speechSynthesis' in window) {
                const lastLap = lapTimes[lapTimes.length - 1];
                const timeStr = lastLap.toFixed(2).replace('.', ' point ');
                const utterance = new SpeechSynthesisUtterance(`Lap ${lapTimes.length}. ${timeStr} seconds.`);
                speechSynthesis.speak(utterance);
            }
        }

        sensitivityRange.addEventListener('input', (e) => {
            sensitivityValue.textContent = e.target.value;
        });
        minLapTimeRange.addEventListener('input', (e) => {
            minLapTimeValue.textContent = parseFloat(e.target.value).toFixed(1);
            MIN_LAP_TIME_MS = parseFloat(e.target.value) * 1000;
        });
        MIN_LAP_TIME_MS = parseFloat(minLapTimeRange.value) * 1000; // Initialize
        minLapTimeValue.textContent = parseFloat(minLapTimeRange.value).toFixed(1);
        sensitivityValue.textContent = sensitivityRange.value;


        function saveDetectionZoneToCookie() {
            if (detectionZone && isValidZone(detectionZone)) {
                document.cookie = `racegow_detectionZone=${JSON.stringify(detectionZone)};max-age=31536000;path=/;samesite=Lax`;
            }
        }
        function loadDetectionZoneFromCookie() {
            const cookies = document.cookie.split(';');
            for (let cookie of cookies) {
                const [name, value] = cookie.trim().split('=');
                if (name === 'racegow_detectionZone') {
                    try {
                        const parsedZone = JSON.parse(value);
                        if (isValidZone(parsedZone)) {
                            detectionZone = parsedZone;
                            console.log("Loaded detection zone from cookie:", detectionZone);
                        } else {
                            console.warn("Invalid detection zone data in cookie, using default.");
                            detectionZone = null; 
                        }
                    } catch (e) {
                        console.error("Error parsing detection zone from cookie:", e);
                        detectionZone = null;
                    }
                    return; 
                }
            }
            detectionZone = null; // Ensure it's null if no valid cookie found
        }

        saveSessionBtn.addEventListener('click', () => {
            const sessionName = sessionNameInput.value.trim() || `Session ${new Date().toLocaleString()}`;
            if (lapTimes.length === 0) {
                alert("No laps to save!");
                return;
            }
            const sessionData = {
                name: sessionName,
                laps: lapTimes,
                date: new Date().toISOString()
            };
            document.cookie = `racegow_lastSession=${JSON.stringify(sessionData)};max-age=31536000;path=/;samesite=Lax`;
            alert(`Session "${sessionName}" saved!`);
        });

        loadSessionBtn.addEventListener('click', () => {
            const cookies = document.cookie.split(';');
            for (let cookie of cookies) {
                const [name, value] = cookie.trim().split('=');
                if (name === 'racegow_lastSession') {
                    try {
                        const sessionData = JSON.parse(value);
                        if (sessionData && sessionData.laps) {
                            if (timerRunning) stopTimerBtn.click();
                            lapTimes = sessionData.laps;
                            sessionNameInput.value = sessionData.name || "Loaded Session";
                            currentLap = lapTimes.length;

                            lapTimesList.innerHTML = '';
                            lapTimes.forEach((lapTime, index) => {
                                const li = document.createElement('li');
                                li.textContent = `Lap ${index + 1}: ${lapTime.toFixed(3)}s`;
                                lapTimesList.prepend(li);
                            });
                            const items = Array.from(lapTimesList.childNodes);
                            items.reverse().forEach(item => lapTimesList.appendChild(item));

                            updateLapDisplay();
                            statusMessage.textContent = `Loaded session: "${sessionNameInput.value}"`;
                            statusMessage.className = "status-message status-info";
                            alert(`Session "${sessionNameInput.value}" loaded.`);
                        } else {
                             alert("No valid session data found in cookie.");
                        }
                    } catch (e) {
                        console.error("Error parsing session from cookie:", e);
                        alert("Error loading session from cookie.");
                    }
                    return;
                }
            }
            alert("No saved session found.");
        });

        init();
    </script>
</body>
</html>