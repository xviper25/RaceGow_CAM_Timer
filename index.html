<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Racegow FPV Lap Timer</title>
    <style>
        :root {
            --primary-color: #007bff; /* Racegow Blue (example) */
            --secondary-color: #6c757d;
            --background-color: #f0f2f5;
            --surface-color: #ffffff;
            --text-color: #333;
            --success-color: #28a745;
            --warning-color: #ffc107;
            --danger-color: #dc3545;
            --font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            font-family: var(--font-family);
            margin: 0;
            padding: 0;
            background-color: var(--background-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            overscroll-behavior: none; /* Prevents pull-to-refresh on mobile */
        }

        .container {
            width: 100%;
            max-width: 600px; /* Max width for larger screens, full width on mobile */
            padding: 15px;
            box-sizing: border-box;
        }

        header {
            background-color: var(--primary-color);
            color: white;
            padding: 15px;
            text-align: center;
            font-size: 1.5em;
            font-weight: bold;
            width: 100%;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 15px;
        }
        header h1 {
            margin: 0;
            font-size: 1.2em; /* Adjusted for better mobile view */
        }

        .video-container {
            position: relative;
            width: 100%;
            background-color: #000;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }

        #videoFeed {
            width: 100%;
            display: block;
            transform: scaleX(-1); /* Mirror front camera */
        }

        #detectionCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .controls, .session-controls, .stats-display, .lap-list-container {
            background-color: var(--surface-color);
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .controls h2, .session-controls h2, .stats-display h2, .lap-list-container h2 {
            margin-top: 0;
            font-size: 1.2em;
            color: var(--primary-color);
            border-bottom: 1px solid #eee;
            padding-bottom: 8px;
        }

        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 10px 15px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.2s ease;
        }
        button:hover {
            background-color: #0056b3;
        }
        button:disabled {
            background-color: var(--secondary-color);
            cursor: not-allowed;
        }
        .btn-success { background-color: var(--success-color); }
        .btn-success:hover { background-color: #1e7e34; }
        .btn-warning { background-color: var(--warning-color); color: #333; }
        .btn-warning:hover { background-color: #d39e00; }
        .btn-danger { background-color: var(--danger-color); }
        .btn-danger:hover { background-color: #bd2130; }


        input[type="text"], input[type="range"] {
            padding: 8px;
            margin: 5px 0;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box;
            width: calc(100% - 10px);
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        .slider-container label {
            margin-right: 10px;
            white-space: nowrap;
        }
        .slider-container input[type="range"] {
            flex-grow: 1;
        }
        .slider-container span {
            min-width: 30px;
            text-align: right;
        }


        #lapTimesList {
            list-style-type: none;
            padding: 0;
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #eee;
            border-radius: 4px;
        }
        #lapTimesList li {
            padding: 8px 10px;
            border-bottom: 1px solid #eee;
        }
        #lapTimesList li:last-child {
            border-bottom: none;
        }
        #lapTimesList li.best-lap {
            background-color: #e6ffed;
            font-weight: bold;
        }

        .status-message {
            padding: 10px;
            margin-bottom: 15px;
            border-radius: 5px;
            text-align: center;
        }
        .status-info { background-color: #e7f3fe; color: #0c5460; border: 1px solid #b8daff;}
        .status-error { background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6cb;}

        .flex-controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-around;
        }
        .flex-controls button {
            flex-grow: 1;
            margin: 5px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            text-align: center;
        }
        .stat-item {
            background-color: #f9f9f9;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #eee;
        }
        .stat-item .label {
            font-size: 0.8em;
            color: var(--secondary-color);
            display: block;
            margin-bottom: 5px;
        }
        .stat-item .value {
            font-size: 1.4em;
            font-weight: bold;
            color: var(--primary-color);
        }
        .stat-item .value.small {
            font-size: 1em;
        }

        /* For drawing instruction */
        #instructionOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
            font-size: 1.2em;
            z-index: 10;
            pointer-events: none; /* Allow clicks to pass through to canvas for drawing */
        }
    </style>
</head>
<body>
    <header>
        <h1>Racegow FPV Lap Timer</h1>
    </header>

    <div class="container">
        <div id="statusMessage" class="status-message status-info">Initializing...</div>

        <div class="video-container">
            <video id="videoFeed" playsinline autoplay muted></video>
            <canvas id="detectionCanvas"></canvas>
            <div id="instructionOverlay" style="display: none;">Draw detection zone on video</div>
        </div>

        <div class="controls">
            <h2>Timer Controls</h2>
            <div class="flex-controls">
                <button id="startTimerBtn" class="btn-success">Start Timer</button>
                <button id="stopTimerBtn" disabled class="btn-danger">Stop Timer</button>
                <button id="resetTimerBtn" class="btn-warning">Reset All</button>
            </div>
            <div class="slider-container">
                <label for="sensitivityRange">Sensitivity:</label>
                <input type="range" id="sensitivityRange" min="5" max="50" value="20">
                <span id="sensitivityValue">20</span>
            </div>
            <div class="slider-container">
                <label for="minLapTimeRange">Min Lap (s):</label>
                <input type="range" id="minLapTimeRange" min="0.5" max="5" step="0.1" value="1.0">
                <span id="minLapTimeValue">1.0</span>
            </div>
        </div>

        <div class="stats-display">
            <h2>Live Stats</h2>
            <div class="stats-grid">
                <div class="stat-item">
                    <span class="label">Current Lap</span>
                    <span class="value" id="lapCount">0</span>
                </div>
                <div class="stat-item">
                    <span class="label">Last Lap</span>
                    <span class="value" id="lastLapTime">0.000s</span>
                </div>
                <div class="stat-item">
                    <span class="label">Best Lap</span>
                    <span class="value" id="bestLapTime">N/A</span>
                </div>
            </div>
             <div class="stat-item" style="margin-top:10px;">
                <span class="label">Best 3 Consecutive</span>
                <span class="value small" id="best3Consecutive">-</span>
            </div>
            <div class="stat-item">
                <span class="label">Total Time</span>
                <span class="value" id="totalTime">0.000s</span>
            </div>
        </div>

        <div class="lap-list-container">
            <h2>Lap Times</h2>
            <ul id="lapTimesList">
                <!-- Lap times will be added here -->
            </ul>
        </div>

        <div class="session-controls">
            <h2>Session Management</h2>
            <input type="text" id="sessionName" placeholder="Enter session name (e.g., Track A - Evening)">
            <button id="saveSessionBtn">Save Laps</button>
            <button id="loadSessionBtn">Load Last Session</button>
             <p style="font-size: 0.8em; color: var(--secondary-color);">Sessions are saved in your browser's cookies.</p>
        </div>
    </div>

    <script>
        const video = document.getElementById('videoFeed');
        const canvas = document.getElementById('detectionCanvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true }); // willReadFrequently for performance
        const instructionOverlay = document.getElementById('instructionOverlay');

        const startTimerBtn = document.getElementById('startTimerBtn');
        const stopTimerBtn = document.getElementById('stopTimerBtn');
        const resetTimerBtn = document.getElementById('resetTimerBtn');
        
        const sensitivityRange = document.getElementById('sensitivityRange');
        const sensitivityValue = document.getElementById('sensitivityValue');
        const minLapTimeRange = document.getElementById('minLapTimeRange');
        const minLapTimeValue = document.getElementById('minLapTimeValue');

        const lapCountDisplay = document.getElementById('lapCount');
        const lastLapTimeDisplay = document.getElementById('lastLapTime');
        const bestLapTimeDisplay = document.getElementById('bestLapTime');
        const totalTimeDisplay = document.getElementById('totalTime');
        const best3ConsecutiveDisplay = document.getElementById('best3Consecutive');
        const lapTimesList = document.getElementById('lapTimesList');
        const sessionNameInput = document.getElementById('sessionName');
        const saveSessionBtn = document.getElementById('saveSessionBtn');
        const loadSessionBtn = document.getElementById('loadSessionBtn');
        const statusMessage = document.getElementById('statusMessage');

        let stream;
        let detectionZone = null; // { x, y, width, height }
        let isDrawing = false;
        let startX, startY;

        let timerRunning = false;
        let lapStartTime = 0;
        let currentLap = 0;
        let lapTimes = [];
        let lastTriggerTime = 0;
        let animationFrameId;
        let prevImageData = null;
        let totalStartTime = 0;

        const MOTION_THRESHOLD_BASE = 20; // This will be scaled by sensitivity
        let MIN_LAP_TIME_MS = 1000; // 1 second default, configurable

        // --- Initialization ---
        async function init() {
            try {
                statusMessage.textContent = "Requesting camera access...";
                statusMessage.className = "status-message status-info";
                stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' } }); // selfie camera
                video.srcObject = stream;
                await video.play(); // Ensure video is playing before setting canvas size

                // Set canvas dimensions once video is playing and has metadata
                video.onloadedmetadata = () => {
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    statusMessage.textContent = "Camera active. Please draw detection zone.";
                    instructionOverlay.style.display = 'flex';
                    // Try to load a previously defined zone
                    loadDetectionZoneFromCookie(); 
                    if (detectionZone) {
                         drawDetectionZone(); // Redraw if loaded
                         instructionOverlay.style.display = 'none';
                         statusMessage.textContent = "Detection zone loaded. Ready to start.";
                    }
                };
            } catch (err) {
                console.error("Error accessing camera:", err);
                statusMessage.textContent = `Error: ${err.name}. Ensure camera access is allowed.`;
                statusMessage.className = "status-message status-error";
                startTimerBtn.disabled = true;
            }
        }

        // --- Detection Zone Drawing ---
        canvas.addEventListener('mousedown', (e) => {
            if (timerRunning) return;
            const rect = canvas.getBoundingClientRect();
            startX = (e.clientX - rect.left) * (canvas.width / rect.width);
            startY = (e.clientY - rect.top) * (canvas.height / rect.height);
            isDrawing = true;
            detectionZone = null; // Clear previous zone while drawing new one
            instructionOverlay.style.display = 'none'; // Hide instruction once drawing starts
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!isDrawing || timerRunning) return;
            const rect = canvas.getBoundingClientRect();
            let currentX = (e.clientX - rect.left) * (canvas.width / rect.width);
            let currentY = (e.clientY - rect.top) * (canvas.height / rect.height);
            
            clearCanvas();
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.7)';
            ctx.lineWidth = 3;
            ctx.strokeRect(startX, startY, currentX - startX, currentY - startY);
        });

        canvas.addEventListener('mouseup', (e) => {
            if (!isDrawing || timerRunning) return;
            isDrawing = false;
            const rect = canvas.getBoundingClientRect();
            let endX = (e.clientX - rect.left) * (canvas.width / rect.width);
            let endY = (e.clientY - rect.top) * (canvas.height / rect.height);

            detectionZone = {
                x: Math.min(startX, endX),
                y: Math.min(startY, endY),
                width: Math.abs(endX - startX),
                height: Math.abs(endY - startY)
            };

            if (detectionZone.width < 10 || detectionZone.height < 10) { // Zone too small
                detectionZone = null;
                clearCanvas();
                statusMessage.textContent = "Detection zone too small. Please redraw.";
                statusMessage.className = "status-message status-warning";
                instructionOverlay.style.display = 'flex';
                return;
            }
            
            drawDetectionZone();
            saveDetectionZoneToCookie();
            statusMessage.textContent = "Detection zone set. Ready to start.";
            statusMessage.className = "status-message status-info";
        });

        function drawDetectionZone() {
            clearCanvas();
            if (detectionZone) {
                ctx.strokeStyle = 'rgba(0, 255, 0, 0.8)'; // Green for set zone
                ctx.lineWidth = 3;
                ctx.strokeRect(detectionZone.x, detectionZone.y, detectionZone.width, detectionZone.height);
            }
        }
        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        // --- Motion Detection ---
        function detectMotion() {
            if (!timerRunning || !detectionZone || !video.videoWidth) { // video.videoWidth to ensure video is ready
                if(timerRunning) animationFrameId = requestAnimationFrame(detectMotion);
                return;
            }

            // Draw video frame to canvas (only the ROI for processing)
            // Create an offscreen canvas for faster processing of ROI
            const offscreenCanvas = document.createElement('canvas');
            const offscreenCtx = offscreenCanvas.getContext('2d', { willReadFrequently: true });
            offscreenCanvas.width = detectionZone.width;
            offscreenCanvas.height = detectionZone.height;

            // Draw the specific region of the video onto the offscreen canvas
            // Correct for mirrored video: video total width - zone.x - zone.width
            const sourceX = video.videoWidth - detectionZone.x - detectionZone.width;
            offscreenCtx.drawImage(video, 
                                   sourceX, detectionZone.y, detectionZone.width, detectionZone.height,
                                   0, 0, detectionZone.width, detectionZone.height);
            
            const currentFrameData = offscreenCtx.getImageData(0, 0, detectionZone.width, detectionZone.height);
            
            if (prevImageData) {
                let diff = 0;
                for (let i = 0; i < currentFrameData.data.length; i += 4) {
                    // Basic pixel difference (grayscale could be more robust but this is simpler)
                    diff += Math.abs(currentFrameData.data[i] - prevImageData.data[i]);
                    diff += Math.abs(currentFrameData.data[i+1] - prevImageData.data[i+1]);
                    diff += Math.abs(currentFrameData.data[i+2] - prevImageData.data[i+2]);
                }
                const avgDiff = diff / (currentFrameData.data.length / 4); // Average difference per pixel
                
                // Adjust threshold based on sensitivity slider (lower slider value = higher sensitivity = lower threshold)
                const motionThreshold = MOTION_THRESHOLD_BASE * ( (55 - parseInt(sensitivityRange.value)) / 30 );


                if (avgDiff > motionThreshold) {
                    triggerLap();
                    // Flash detection zone
                    ctx.fillStyle = 'rgba(255, 255, 0, 0.5)'; // Yellow flash
                    ctx.fillRect(detectionZone.x, detectionZone.y, detectionZone.width, detectionZone.height);
                    setTimeout(() => drawDetectionZone(), 100); // Redraw normal zone after flash
                }
            }
            prevImageData = currentFrameData;
            animationFrameId = requestAnimationFrame(detectMotion);
        }

        // --- Timer Logic ---
        startTimerBtn.addEventListener('click', () => {
            if (!detectionZone) {
                statusMessage.textContent = "Please draw a detection zone first!";
                statusMessage.className = "status-message status-warning";
                instructionOverlay.style.display = 'flex';
                return;
            }
            if (timerRunning) return;

            timerRunning = true;
            startTimerBtn.disabled = true;
            stopTimerBtn.disabled = false;
            resetTimerBtn.disabled = true; // Disable reset while running
            sensitivityRange.disabled = true;
            minLapTimeRange.disabled = true;
            
            lapStartTime = performance.now();
            if (currentLap === 0) { // First start or after reset
                totalStartTime = lapStartTime;
            }
            lastTriggerTime = performance.now() - MIN_LAP_TIME_MS; // Allow immediate first trigger
            
            statusMessage.textContent = "Timer started. Listening for motion...";
            statusMessage.className = "status-message status-info";
            
            prevImageData = null; // Reset previous frame on start
            detectMotion();
            updateTotalTimeDisplay(); // Start total time display
        });

        stopTimerBtn.addEventListener('click', () => {
            if (!timerRunning) return;
            timerRunning = false;
            cancelAnimationFrame(animationFrameId);
            startTimerBtn.disabled = false;
            stopTimerBtn.disabled = true;
            resetTimerBtn.disabled = false;
            sensitivityRange.disabled = false;
            minLapTimeRange.disabled = false;
            prevImageData = null;
            statusMessage.textContent = "Timer stopped. Define zone or start again.";
            statusMessage.className = "status-message status-info";
        });

        resetTimerBtn.addEventListener('click', () => {
            stopTimerBtn.click(); // Stop if running
            currentLap = 0;
            lapTimes = [];
            lapStartTime = 0;
            totalStartTime = 0;
            prevImageData = null;
            updateLapDisplay();
            lapTimesList.innerHTML = '';
            bestLapTimeDisplay.textContent = "N/A";
            best3ConsecutiveDisplay.textContent = "-";
            totalTimeDisplay.textContent = "0.000s";
            lapCountDisplay.textContent = "0";
            lastLapTimeDisplay.textContent = "0.000s";
            sessionNameInput.value = ''; // Clear session name on reset
            statusMessage.textContent = "Timer reset. Draw zone and start.";
            statusMessage.className = "status-message status-info";
            if (!detectionZone) instructionOverlay.style.display = 'flex';
        });

        function triggerLap() {
            const now = performance.now();
            if (now - lastTriggerTime < MIN_LAP_TIME_MS) {
                return; // Debounce
            }
            lastTriggerTime = now;

            if (currentLap > 0 || lapTimes.length > 0) { // Don't record "lap 0" time if it's the very first trigger
                 const lapTime = (now - lapStartTime) / 1000;
                 lapTimes.push(lapTime);
            } else if (currentLap === 0 && lapTimes.length === 0) {
                 // This is the first trigger, marks the end of the "formation lap" and start of lap 1 time
                 totalStartTime = now; // Actual race start time
            }


            currentLap++;
            lapStartTime = now; // Reset lap start time for the next lap
            
            updateLapDisplay();
            speakLapTime();
        }

        function updateTotalTimeDisplay() {
            if (timerRunning) {
                const elapsed = (performance.now() - totalStartTime) / 1000;
                totalTimeDisplay.textContent = elapsed.toFixed(3) + 's';
                requestAnimationFrame(updateTotalTimeDisplay);
            } else if (lapTimes.length > 0) { // When stopped, show sum of recorded laps
                 const sumOfLaps = lapTimes.reduce((sum, t) => sum + t, 0);
                 totalTimeDisplay.textContent = sumOfLaps.toFixed(3) + 's';
            } else {
                totalTimeDisplay.textContent = "0.000s";
            }
        }

        // --- UI Updates & Calculations ---
        function updateLapDisplay() {
            lapCountDisplay.textContent = currentLap;
            if (lapTimes.length > 0) {
                const lastLap = lapTimes[lapTimes.length - 1];
                lastLapTimeDisplay.textContent = lastLap.toFixed(3) + 's';

                const li = document.createElement('li');
                li.textContent = `Lap ${lapTimes.length}: ${lastLap.toFixed(3)}s`;
                lapTimesList.prepend(li); // Add to top

                updateBestLap();
                updateBest3Consecutive();
            } else {
                lastLapTimeDisplay.textContent = "0.000s";
            }
            updateTotalTimeDisplay(); // Recalculate total time display
        }

        function updateBestLap() {
            if (lapTimes.length === 0) {
                bestLapTimeDisplay.textContent = "N/A";
                return;
            }
            const best = Math.min(...lapTimes);
            bestLapTimeDisplay.textContent = best.toFixed(3) + 's';

            // Highlight best lap in list
            const lis = lapTimesList.getElementsByTagName('li');
            for (let li of lis) {
                li.classList.remove('best-lap');
                if (parseFloat(li.textContent.split(': ')[1]) === best) {
                    li.classList.add('best-lap');
                }
            }
        }

        function updateBest3Consecutive() {
            if (lapTimes.length < 3) {
                best3ConsecutiveDisplay.textContent = "-";
                return;
            }
            let minSum = Infinity;
            let bestStartIndex = -1;

            for (let i = 0; i <= lapTimes.length - 3; i++) {
                const currentSum = lapTimes[i] + lapTimes[i+1] + lapTimes[i+2];
                if (currentSum < minSum) {
                    minSum = currentSum;
                    bestStartIndex = i;
                }
            }
            if (bestStartIndex !== -1) {
                const laps = lapTimes.slice(bestStartIndex, bestStartIndex + 3);
                best3ConsecutiveDisplay.textContent = 
                    `Laps ${bestStartIndex + 1}-${bestStartIndex + 3}: ${minSum.toFixed(3)}s ` +
                    `(${laps.map(t => t.toFixed(2)).join(', ')})`;
            } else {
                 best3ConsecutiveDisplay.textContent = "-";
            }
        }

        // --- Speech Synthesis ---
        function speakLapTime() {
            if (lapTimes.length > 0 && 'speechSynthesis' in window) {
                const lastLap = lapTimes[lapTimes.length - 1];
                const timeStr = lastLap.toFixed(2).replace('.', ' point '); // e.g. "12 point 34"
                const utterance = new SpeechSynthesisUtterance(`Lap ${lapTimes.length}. ${timeStr} seconds.`);
                speechSynthesis.speak(utterance);
            }
        }

        // --- Settings ---
        sensitivityRange.addEventListener('input', (e) => {
            sensitivityValue.textContent = e.target.value;
        });
        minLapTimeRange.addEventListener('input', (e) => {
            minLapTimeValue.textContent = parseFloat(e.target.value).toFixed(1);
            MIN_LAP_TIME_MS = parseFloat(e.target.value) * 1000;
        });
        // Initialize MIN_LAP_TIME_MS from range default
        MIN_LAP_TIME_MS = parseFloat(minLapTimeRange.value) * 1000;
        minLapTimeValue.textContent = parseFloat(minLapTimeRange.value).toFixed(1);
        sensitivityValue.textContent = sensitivityRange.value;


        // --- Session Management (Cookies) ---
        function saveDetectionZoneToCookie() {
            if (detectionZone) {
                document.cookie = `racegow_detectionZone=${JSON.stringify(detectionZone)};max-age=31536000;path=/`; // Expires in 1 year
            }
        }
        function loadDetectionZoneFromCookie() {
            const cookies = document.cookie.split(';');
            for (let cookie of cookies) {
                const [name, value] = cookie.trim().split('=');
                if (name === 'racegow_detectionZone') {
                    try {
                        detectionZone = JSON.parse(value);
                        if (detectionZone && detectionZone.x !== undefined) { // Basic validation
                            console.log("Loaded detection zone from cookie:", detectionZone);
                            // Will be drawn by init if video is ready
                        } else {
                            detectionZone = null;
                        }
                    } catch (e) {
                        console.error("Error parsing detection zone from cookie:", e);
                        detectionZone = null;
                    }
                    return;
                }
            }
        }


        saveSessionBtn.addEventListener('click', () => {
            const sessionName = sessionNameInput.value.trim() || `Session ${new Date().toLocaleString()}`;
            if (lapTimes.length === 0) {
                alert("No laps to save!");
                return;
            }
            const sessionData = {
                name: sessionName,
                laps: lapTimes,
                date: new Date().toISOString()
            };
            // For simplicity, we'll save just the last session. A more robust system would store multiple.
            document.cookie = `racegow_lastSession=${JSON.stringify(sessionData)};max-age=31536000;path=/`; // Expires in 1 year
            alert(`Session "${sessionName}" saved!`);
        });

        loadSessionBtn.addEventListener('click', () => {
            const cookies = document.cookie.split(';');
            for (let cookie of cookies) {
                const [name, value] = cookie.trim().split('=');
                if (name === 'racegow_lastSession') {
                    try {
                        const sessionData = JSON.parse(value);
                        if (sessionData && sessionData.laps) {
                            resetTimerBtn.click(); // Clear current state
                            lapTimes = sessionData.laps;
                            sessionNameInput.value = sessionData.name || "Loaded Session";
                            currentLap = lapTimes.length; // Set current lap number based on loaded laps

                            lapTimesList.innerHTML = ''; // Clear current list
                            lapTimes.forEach((lapTime, index) => {
                                const li = document.createElement('li');
                                li.textContent = `Lap ${index + 1}: ${lapTime.toFixed(3)}s`;
                                lapTimesList.prepend(li); // Prepend to keep order correct (newest at top)
                            });
                            // Reverse the list items after prepending all to get correct visual order (Lap 1 at top)
                            const items = Array.from(lapTimesList.childNodes);
                            items.reverse().forEach(item => lapTimesList.appendChild(item));


                            updateLapDisplay(); // This will also call sub-updates
                            statusMessage.textContent = `Loaded session: "${sessionNameInput.value}"`;
                            statusMessage.className = "status-message status-info";
                            alert(`Session "${sessionNameInput.value}" loaded.`);
                        } else {
                             alert("No valid session data found in cookie.");
                        }
                    } catch (e) {
                        console.error("Error parsing session from cookie:", e);
                        alert("Error loading session from cookie.");
                    }
                    return;
                }
            }
            alert("No saved session found.");
        });

        // --- Start everything ---
        init();

    </script>
</body>
</html>