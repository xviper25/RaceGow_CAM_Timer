<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Racegow FPV Lap Timer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.9.4/Chart.js"></script>
    <style>
        :root {
            --primary-color: #007bff;
            --secondary-color: #6c757d;
            --background-color: #f0f2f5;
            --surface-color: #ffffff;
            --text-color: #333;
            --success-color: #28a745;
            --warning-color: #ffc107;
            --danger-color: #dc3545;
            --font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        body { font-family: var(--font-family); margin: 0; padding: 0; background-color: var(--background-color); color: var(--text-color); display: flex; flex-direction: column; align-items: center; overscroll-behavior: none; }
        .container { width: 100%; max-width: 600px; padding: 15px; box-sizing: border-box; }
        header { background-color: var(--primary-color); color: white; padding: 15px; text-align: center; font-size: 1.5em; font-weight: bold; width: 100%; box-shadow: 0 2px 4px rgba(0,0,0,0.1); margin-bottom: 15px; }
        header h1 { margin: 0; font-size: 1.2em; }
        .video-container { position: relative; width: 100%; background-color: #000; border-radius: 8px; overflow: hidden; box-shadow: 0 2px 8px rgba(0,0,0,0.15); }
        #videoFeed { width: 100%; display: block; }
        #detectionCanvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        #zoneInstructionOverlay { position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%); background-color: rgba(0,0,0,0.7); color: white; padding: 8px 15px; border-radius: 5px; font-size: 0.9em; text-align: center; z-index: 20; display: none; pointer-events: none; transition: opacity 0.4s ease-out; }
        .camera-controls { background-color: var(--surface-color); padding: 10px 15px; margin-bottom: 15px; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
        .camera-controls h2 { margin-top: 0; font-size: 1.2em; color: var(--primary-color); border-bottom: 1px solid #eee; padding-bottom: 8px; }
        .camera-controls select { width: 100%; padding: 8px; border-radius: 4px; border: 1px solid #ccc; font-size: 1em; margin-top: 5px; box-sizing: border-box; }
        .zone-setup-controls { background-color: var(--surface-color); padding: 15px; margin-bottom: 15px; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
        .zone-setup-controls h2 { margin-top: 0; font-size: 1.2em; color: var(--primary-color); border-bottom: 1px solid #eee; padding-bottom: 8px; }
        .zone-slider-group { margin-bottom: 10px; display: flex; align-items: center; }
        .zone-slider-group label { flex-basis: 100px; /* Fixed width for labels */ margin-right: 10px; font-size: 0.9em; color: var(--secondary-color); white-space: nowrap; }
        .zone-slider-group input[type="range"] { flex-grow: 1; margin-right: 10px; }
        .zone-slider-group span { font-size: 0.9em; min-width: 35px; text-align: right; }

       .controls, .session-controls, .stats-display, .lap-list-container { background-color: var(--surface-color); padding: 15px; margin-bottom: 15px; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
       .controls h2, .session-controls h2, .stats-display h2, .lap-list-container h2 { margin-top: 0; font-size: 1.2em; color: var(--primary-color); border-bottom: 1px solid #eee; padding-bottom: 8px; }
       button { background-color: var(--primary-color); color: white; border: none; padding: 10px 15px; margin: 5px; border-radius: 5px; cursor: pointer; font-size: 1em; transition: background-color 0.2s ease; }
       button:hover:not(:disabled) { background-color: #0056b3; }
       button:disabled { background-color: var(--secondary-color); cursor: not-allowed; }
       .btn-success { background-color: var(--success-color); } .btn-success:hover:not(:disabled) { background-color: #1e7e34; }
       .btn-warning { background-color: var(--warning-color); color: #333; } .btn-warning:hover:not(:disabled) { background-color: #d39e00; }
       .btn-danger { background-color: var(--danger-color); } .btn-danger:hover:not(:disabled) { background-color: #bd2130; }
       input[type="text"], input[type="range"]:not(.zone-slider-group input[type="range"]) { padding: 8px; margin: 5px 0; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box; width: calc(100% - 10px); }
       .slider-container { display: flex; align-items: center; margin-bottom: 10px; }
       .slider-container label { margin-right: 10px; white-space: nowrap; }
       .slider-container input[type="range"] { flex-grow: 1; }
       .slider-container span { min-width: 30px; text-align: right; }
       #lapTimesList { list-style-type: none; padding: 0; max-height: 200px; overflow-y: auto; border: 1px solid #eee; border-radius: 4px; }
       #lapTimesList li { padding: 8px 10px; border-bottom: 1px solid #eee; } #lapTimesList li:last-child { border-bottom: none; }
       #lapTimesList li.best-lap { background-color: #e6ffed; font-weight: bold; }
       .status-message { padding: 10px; margin-bottom: 15px; border-radius: 5px; text-align: center; }
       .status-info { background-color: #e7f3fe; color: #0c5460; border: 1px solid #b8daff;}
       .status-error { background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6cb;}
       .status-warning { background-color: #fff3cd; color: #856404; border: 1px solid #ffeeba; }
       .status-success { background-color: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
       .flex-controls { display: flex; flex-wrap: wrap; justify-content: space-around; }
       .flex-controls button { flex-grow: 1; margin: 5px; }
       .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 10px; text-align: center; }
       .stat-item { background-color: #f9f9f9; padding: 10px; border-radius: 5px; border: 1px solid #eee; }
       .stat-item .label { font-size: 0.8em; color: var(--secondary-color); display: block; margin-bottom: 5px; }
       .stat-item .value { font-size: 1.4em; font-weight: bold; color: var(--primary-color); }
       .stat-item .value.small { font-size: 1em; }
        .track-management, .track-stats-view { background-color: var(--surface-color); padding: 15px; margin-bottom: 15px; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
        .track-management h2, .track-stats-view h2 { margin-top: 0; font-size: 1.2em; color: var(--primary-color); border-bottom: 1px solid #eee; padding-bottom: 8px; }
        .track-management select, .track-management input[type="text"] { width: 100%; padding: 8px; margin-bottom:10px; border-radius: 4px; border: 1px solid #ccc; font-size: 1em; box-sizing: border-box; }
        .track-management .button-group { display: flex; justify-content: space-between; }
        .track-management .button-group button { flex-grow: 1; margin: 0 5px; }
        .track-management .button-group button:first-child { margin-left: 0; }
        .track-management .button-group button:last-child { margin-right: 0; }
        #trackStatsContent h3 { color: var(--primary-color); margin-top: 20px; }
        #pastSessionsList { list-style-type: none; padding: 0; }
        #pastSessionsList li { background-color: #f9f9f9; padding: 10px; margin-bottom: 8px; border-radius: 4px; border: 1px solid #eee; font-size:0.9em; }
        #pastSessionsList li strong { display: block; margin-bottom: 5px; color: var(--text-color); }
        #progressionChartContainer { margin-top: 20px; background-color: #fff; padding:10px; border-radius: 5px; position: relative; height: 300px; /* Give chart a height */}
        .main-timer-content, #trackStatsView { display: none; }
    </style>
</head>
<body>
    <header><h1>Racegow FPV Lap Timer</h1></header>
    <div class="container">
        <div id="statusMessage" class="status-message status-info">Initializing...</div>
        <div id="trackManagementSection" class="track-management">
            <h2>Track Selection</h2><label for="existingTrackSelect">Select Existing Track:</label><select id="existingTrackSelect"></select>
            <div class="button-group"><button id="selectTrackBtn" class="btn-success">Load Track</button><button id="deleteTrackBtn" class="btn-danger">Delete Selected</button></div>
            <hr style="margin: 15px 0;"><label for="newTrackNameInput">Or Create New Track:</label><input type="text" id="newTrackNameInput" placeholder="Enter new track name">
            <button id="createTrackBtn" style="width:100%;" class="btn-primary">Create & Load Track</button>
        </div>
        <div class="main-timer-content">
            <div class="camera-controls"><h2 id="currentTrackNameDisplay">Current Track: None</h2><select id="cameraSelect"></select></div>
            <div class="video-container">
                <video id="videoFeed" playsinline autoplay muted></video><canvas id="detectionCanvas"></canvas>
                <div id="zoneInstructionOverlay">Adjust zone using sliders below, then start.</div>
            </div>
            <div class="zone-setup-controls">
                <h2>Detection Zone Setup</h2>
                <div class="zone-slider-group"><label for="offsetTopSlider">Offset Top:</label><input type="range" id="offsetTopSlider" min="0" max="100" value="25"><span id="offsetTopValue"></span></div>
                <div class="zone-slider-group"><label for="offsetBottomSlider">Offset Bottom:</label><input type="range" id="offsetBottomSlider" min="0" max="100" value="25"><span id="offsetBottomValue"></span></div>
                <div class="zone-slider-group"><label for="offsetLeftSlider">Offset Left:</label><input type="range" id="offsetLeftSlider" min="0" max="100" value="25"><span id="offsetLeftValue"></span></div>
                <div class="zone-slider-group"><label for="offsetRightSlider">Offset Right:</label><input type="range" id="offsetRightSlider" min="0" max="100" value="25"><span id="offsetRightValue"></span></div>
            </div>
            <div class="controls">
                <h2>Timer Controls</h2>
                <div class="flex-controls"><button id="startTimerBtn" class="btn-success" disabled>Start Session</button><button id="stopTimerBtn" disabled class="btn-danger">Stop & Save Session</button><button id="resetTimerBtn" class="btn-warning">Clear Laps</button></div>
                <div class="slider-container"><label for="sensitivityRange">Sensitivity (1=Max):</label><input type="range" id="sensitivityRange" min="1" max="30" value="5"><span id="sensitivityValue">5</span></div>
                <div class="slider-container"><label for="minLapTimeRange">Min Lap (s):</label><input type="range" id="minLapTimeRange" min="0.5" max="5" step="0.1" value="1.0"><span id="minLapTimeValue">1.0</span></div>
            </div>
            <div class="stats-display">
                <h2>Live Session Stats</h2>
                <div class="stats-grid">
                    <div class="stat-item"><span class="label">Current Lap</span><span class="value" id="lapCount">0</span></div>
                    <div class="stat-item"><span class="label">Last Lap</span><span class="value" id="lastLapTime">0.000s</span></div>
                    <div class="stat-item"><span class="label">Best Lap</span><span class="value" id="bestLapTime">N/A</span></div>
                </div>
                <div class="stat-item" style="margin-top:10px;"><span class="label">Best 3 Consecutive</span><span class="value small" id="best3Consecutive">-</span></div>
                <div class="stat-item"><span class="label">Total Time</span><span class="value" id="totalTime">0.000s</span></div>
            </div>
            <div class="lap-list-container"><h2>Session Lap Times</h2><ul id="lapTimesList"></ul></div>
            <div class="session-controls">
                <h2>Session Actions</h2><button id="viewTrackStatsBtn" class="btn-primary">View Track Stats</button><button id="changeTrackBtn" class="btn-warning">Change Track</button>
            </div>
        </div>
        <div id="trackStatsView" class="track-stats-view">
            <h2 id="trackStatsNameDisplay">Track Stats for: </h2>
            <div id="trackStatsContent">
                <h3>Overall Records</h3><p><strong>Best Lap:</strong> <span id="overallBestLapDisplay">N/A</span></p><p><strong>Best 3 Consecutive:</strong> <span id="overallBest3ConsecutiveDisplay">N/A</span></p>
                <h3>Progression Graph</h3><div id="progressionChartContainer"><canvas id="progressionChartCanvas"></canvas><p style="text-align:center; font-style:italic;">(Chart.js graph would appear here)</p></div>
                <h3>Past Sessions</h3><ul id="pastSessionsList"></ul>
            </div>
            <button id="backToTimerBtn" class="btn-primary">Back to Timer</button>
        </div>
    </div>

    <script>
        const video = document.getElementById('videoFeed');
        const videoContainer = document.querySelector('.video-container');
        const canvasEl = document.getElementById('detectionCanvas');
        const ctx = canvasEl.getContext('2d', { willReadFrequently: true });
        const zoneInstructionOverlay = document.getElementById('zoneInstructionOverlay');
        const cameraSelect = document.getElementById('cameraSelect');
        const offsetTopSlider = document.getElementById('offsetTopSlider');
        const offsetBottomSlider = document.getElementById('offsetBottomSlider');
        const offsetLeftSlider = document.getElementById('offsetLeftSlider');
        const offsetRightSlider = document.getElementById('offsetRightSlider');
        const offsetTopValue = document.getElementById('offsetTopValue');
        const offsetBottomValue = document.getElementById('offsetBottomValue');
        const offsetLeftValue = document.getElementById('offsetLeftValue');
        const offsetRightValue = document.getElementById('offsetRightValue');
        const startTimerBtn = document.getElementById('startTimerBtn');
        const stopTimerBtn = document.getElementById('stopTimerBtn');
        const resetTimerBtn = document.getElementById('resetTimerBtn');
        const statusMessage = document.getElementById('statusMessage');
        const sensitivityRange = document.getElementById('sensitivityRange');
        const sensitivityValue = document.getElementById('sensitivityValue');
        const minLapTimeRange = document.getElementById('minLapTimeRange');
        const minLapTimeValue = document.getElementById('minLapTimeValue');
        const lapCountDisplay = document.getElementById('lapCount');
        const lastLapTimeDisplay = document.getElementById('lastLapTime');
        const bestLapTimeDisplay = document.getElementById('bestLapTime');
        const totalTimeDisplay = document.getElementById('totalTime');
        const best3ConsecutiveDisplay = document.getElementById('best3Consecutive');
        const lapTimesList = document.getElementById('lapTimesList');
        const trackManagementSection = document.getElementById('trackManagementSection');
        const mainTimerContent = document.querySelector('.main-timer-content');
        const trackStatsView = document.getElementById('trackStatsView');
        const existingTrackSelect = document.getElementById('existingTrackSelect');
        const selectTrackBtn = document.getElementById('selectTrackBtn');
        const deleteTrackBtn = document.getElementById('deleteTrackBtn');
        const newTrackNameInput = document.getElementById('newTrackNameInput');
        const createTrackBtn = document.getElementById('createTrackBtn');
        const currentTrackNameDisplay = document.getElementById('currentTrackNameDisplay');
        const viewTrackStatsBtn = document.getElementById('viewTrackStatsBtn');
        const changeTrackBtn = document.getElementById('changeTrackBtn');
        const trackStatsNameDisplay = document.getElementById('trackStatsNameDisplay');
        const overallBestLapDisplay = document.getElementById('overallBestLapDisplay');
        const overallBest3ConsecutiveDisplay = document.getElementById('overallBest3ConsecutiveDisplay');
        const progressionChartCanvas = document.getElementById('progressionChartCanvas');
        const pastSessionsList = document.getElementById('pastSessionsList');
        const backToTimerBtn = document.getElementById('backToTimerBtn');

        let currentStream = null; let currentDeviceId = null; let videoDevices = []; 
        let detectionZone = { x: 0, y: 0, width: 0, height: 0 };
        let zoneOffsets = { top: 25, bottom: 25, left: 25, right: 25 }; 
        let timerRunning = false;
        let lapStartTime = 0, currentLap = 0, lapTimes = [], lastTriggerTime = 0;
        let animationFrameId, prevImageData = null, totalStartTime = 0;
        const PIXEL_INTENSITY_CHANGE_THRESHOLD = 40; 
        let CHANGED_PIXELS_PERCENTAGE_TRIGGER = 5; 
        let MIN_LAP_TIME_MS = 1000;
        const MIN_ZONE_DIMENSION_CANVAS = 20;
        let raceData = { tracks: {}, currentTrackName: null, lastCameraId: null };
        const LOCAL_STORAGE_KEY = 'racegowFPVData';
        let currentActiveTrackName = null;
        let progressionChartInstance = null;

        async function initApp() {
            loadDataFromLocalStorage(); await populateCameraList(); 
            const savedDeviceId = raceData.lastCameraId || null;
            if (savedDeviceId && videoDevices.find(d => d.deviceId === savedDeviceId)) { currentDeviceId = savedDeviceId;
            } else if (videoDevices.length > 0) {
                const userFacingCamera = videoDevices.find(device => device.label.toLowerCase().includes('front') || device.label.toLowerCase().includes('selfie') || (device.getCapabilities && device.getCapabilities().facingMode && device.getCapabilities().facingMode.includes('user')));
                if (userFacingCamera) { currentDeviceId = userFacingCamera.deviceId; } else { currentDeviceId = videoDevices[0].deviceId; }
            }
            cameraSelect.value = currentDeviceId;
            if (raceData.currentTrackName && raceData.tracks[raceData.currentTrackName]) { currentActiveTrackName = raceData.currentTrackName; await loadTrack(currentActiveTrackName); 
            } else { showTrackManagementView(); populateExistingTrackSelect(); statusMessage.textContent = "Select or create a track to begin."; }
            MIN_LAP_TIME_MS = parseFloat(minLapTimeRange.value) * 1000; minLapTimeValue.textContent = parseFloat(minLapTimeRange.value).toFixed(1);
            CHANGED_PIXELS_PERCENTAGE_TRIGGER = parseFloat(sensitivityRange.value); sensitivityValue.textContent = sensitivityRange.value;
            addEventListeners();
        }

        function addEventListeners() {
            cameraSelect.addEventListener('change', handleCameraChange);
            selectTrackBtn.addEventListener('click', () => { const selectedTrack = existingTrackSelect.value; if(selectedTrack) loadTrack(selectedTrack); else alert("Please select a track from the list."); });
            deleteTrackBtn.addEventListener('click', handleDeleteTrack); createTrackBtn.addEventListener('click', handleCreateTrack);
            viewTrackStatsBtn.addEventListener('click', showTrackStatsView); changeTrackBtn.addEventListener('click', showTrackManagementView);
            backToTimerBtn.addEventListener('click', showTimerView);
            [offsetTopSlider, offsetBottomSlider, offsetLeftSlider, offsetRightSlider].forEach(slider => { slider.min = 0; slider.step = 1; slider.removeEventListener('input', handleZoneOffsetSliderChange); slider.addEventListener('input', handleZoneOffsetSliderChange); });
            startTimerBtn.addEventListener('click', handleStartTimer); stopTimerBtn.addEventListener('click', handleStopTimer); resetTimerBtn.addEventListener('click', handleResetTimer);
            sensitivityRange.addEventListener('input', (e) => { CHANGED_PIXELS_PERCENTAGE_TRIGGER = parseFloat(e.target.value); sensitivityValue.textContent = e.target.value; });
            minLapTimeRange.addEventListener('input', (e) => { minLapTimeValue.textContent = parseFloat(e.target.value).toFixed(1); MIN_LAP_TIME_MS = parseFloat(e.target.value) * 1000; });
        }

        function showTrackManagementView() { trackManagementSection.style.display = 'block'; mainTimerContent.style.display = 'none'; trackStatsView.style.display = 'none'; if(currentStream) { currentStream.getTracks().forEach(track => track.stop()); video.srcObject = null; } populateExistingTrackSelect(); currentActiveTrackName = null; }
        function showTimerView() { trackManagementSection.style.display = 'none'; mainTimerContent.style.display = 'block'; trackStatsView.style.display = 'none'; }
        function showTrackStatsView() { if (!currentActiveTrackName) { alert("No track selected."); return; } populateTrackStats(); trackManagementSection.style.display = 'none'; mainTimerContent.style.display = 'none'; trackStatsView.style.display = 'block'; }

        function loadDataFromLocalStorage() { const data = localStorage.getItem(LOCAL_STORAGE_KEY); if (data) { raceData = JSON.parse(data); if (!raceData.tracks) raceData.tracks = {}; } else { raceData = { tracks: {}, currentTrackName: null, lastCameraId: null }; } }
        function saveDataToLocalStorage() { raceData.currentTrackName = currentActiveTrackName; raceData.lastCameraId = currentDeviceId; localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(raceData)); }

        function populateExistingTrackSelect() { existingTrackSelect.innerHTML = '<option value="">-- Select Track --</option>'; Object.keys(raceData.tracks).sort().forEach(trackName => { const option = document.createElement('option'); option.value = trackName; option.text = trackName; existingTrackSelect.appendChild(option); }); existingTrackSelect.value = currentActiveTrackName || ""; }
        async function loadTrack(trackName) {
            if (!trackName || !raceData.tracks[trackName]) { alert("Track not found or not selected."); showTrackManagementView(); return; }
            currentActiveTrackName = trackName; currentTrackNameDisplay.textContent = `Current Track: ${trackName}`;
            zoneOffsets = raceData.tracks[trackName].zoneOffsets || { top: 20, bottom: 20, left: 20, right: 20 }; // Default if not saved with track
            showTimerView();
            if (!currentStream || video.paused) { await startCameraStream(currentDeviceId); } else { setupZoneOffsetSliders(); updateSlidersFromZoneOffsets(); calculateDetectionZoneFromOffsets(); drawDetectionZoneOutline(); }
            resetCurrentSessionState(); saveDataToLocalStorage();
        }
        function handleCreateTrack() { const newName = newTrackNameInput.value.trim(); if (!newName) { alert("Please enter a track name."); return; } if (raceData.tracks[newName]) { alert("Track name already exists."); return; } raceData.tracks[newName] = { name: newName, zoneOffsets: { top: Math.round(canvasEl.height*0.2), bottom: Math.round(canvasEl.height*0.2), left: Math.round(canvasEl.width*0.2), right: Math.round(canvasEl.width*0.2) }, sessions: [] }; newTrackNameInput.value = ''; populateExistingTrackSelect(); existingTrackSelect.value = newName; loadTrack(newName); }
        function handleDeleteTrack() { const trackNameToDelete = existingTrackSelect.value; if (!trackNameToDelete) { alert("Please select a track to delete."); return; } if (confirm(`Are you sure you want to delete track "${trackNameToDelete}" and all its data?`)) { delete raceData.tracks[trackNameToDelete]; if (currentActiveTrackName === trackNameToDelete) { currentActiveTrackName = null; raceData.currentTrackName = null; } saveDataToLocalStorage(); populateExistingTrackSelect(); if (!currentActiveTrackName) showTrackManagementView(); } }

        async function populateCameraList() { try { if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) { handleError("Media device enumeration not supported by this browser."); return; } const devices = await navigator.mediaDevices.enumerateDevices(); videoDevices = devices.filter(device => device.kind === 'videoinput'); cameraSelect.innerHTML = ''; if (videoDevices.length === 0) { cameraSelect.innerHTML = '<option value="">No cameras found</option>'; handleError("No cameras found on this device."); return; } videoDevices.forEach(device => { const option = document.createElement('option'); option.value = device.deviceId; option.text = device.label || `Camera ${cameraSelect.options.length + 1}`; cameraSelect.appendChild(option); }); } catch (err) { console.error("Error enumerating devices:", err); handleError("Could not list cameras. Please check permissions."); } }
        async function startCameraStream(deviceId) { if (currentStream) { currentStream.getTracks().forEach(track => track.stop()); } statusMessage.textContent = "Initializing camera..."; statusMessage.className = "status-message status-info"; const constraints = { video: { deviceId: deviceId ? { exact: deviceId } : undefined } }; try { currentStream = await navigator.mediaDevices.getUserMedia(constraints); video.srcObject = currentStream; await video.play(); const settings = currentStream.getVideoTracks()[0].getSettings(); video.style.transform = (settings.facingMode === 'user') ? 'scaleX(-1)' : 'scaleX(1)'; currentDeviceId = deviceId; /* raceData.lastCameraId updated in saveData */ video.onloadedmetadata = () => { canvasEl.width = video.videoWidth; canvasEl.height = video.videoHeight; setupZoneOffsetSliders(); updateSlidersFromZoneOffsets(); calculateDetectionZoneFromOffsets(); requestAnimationFrame( () => { drawDetectionZoneOutline(); zoneInstructionOverlay.style.display = 'block'; zoneInstructionOverlay.style.opacity = 1; setTimeout(() => { zoneInstructionOverlay.style.opacity = 0; setTimeout(()=>zoneInstructionOverlay.style.display='none', 500)}, 4000); statusMessage.textContent = "Adjust zone using sliders, then start."; statusMessage.className = "status-message status-info"; checkZoneAndEnableStart(); }); }; video.onerror = (e) => handleError("Video error. Check permissions or try another browser."); } catch (err) { console.error(`Error starting camera ${deviceId}:`, err); handleError(`Could not start camera: ${err.name}. Try another or check permissions.`); } }
        async function handleCameraChange() { const selectedDeviceId = cameraSelect.value; if (selectedDeviceId && selectedDeviceId !== currentDeviceId) { if (timerRunning) { stopTimerBtn.click(); } prevImageData = null; await startCameraStream(selectedDeviceId); } }
        function handleError(message) { statusMessage.textContent = message; statusMessage.className = "status-message status-error"; startTimerBtn.disabled = true; if(zoneInstructionOverlay) zoneInstructionOverlay.style.display = 'none';}
        function calculateDetectionZoneFromOffsets() { if (!canvasEl.width || !canvasEl.height) return false; detectionZone.x = zoneOffsets.left; detectionZone.y = zoneOffsets.top; detectionZone.width = canvasEl.width - zoneOffsets.left - zoneOffsets.right; detectionZone.height = canvasEl.height - zoneOffsets.top - zoneOffsets.bottom; return isValidZone(detectionZone); }
        function areOffsetsValid(offsets, currentCanvasWidth, currentCanvasHeight) { if (!currentCanvasWidth || !currentCanvasHeight) return false; const tempWidth = currentCanvasWidth - offsets.left - offsets.right; const tempHeight = currentCanvasHeight - offsets.top - offsets.bottom; return tempWidth >= MIN_ZONE_DIMENSION_CANVAS && tempHeight >= MIN_ZONE_DIMENSION_CANVAS && offsets.left >= 0 && offsets.right >=0 && offsets.top >=0 && offsets.bottom >=0 && (offsets.left + offsets.right < currentCanvasWidth - MIN_ZONE_DIMENSION_CANVAS / 2) && (offsets.top + offsets.bottom < currentCanvasHeight - MIN_ZONE_DIMENSION_CANVAS / 2); } // Added fudge for safety
        function isValidZone(zone) { return zone && zone.width >= MIN_ZONE_DIMENSION_CANVAS && zone.height >= MIN_ZONE_DIMENSION_CANVAS && zone.x >= 0 && zone.y >= 0 && (zone.x + zone.width) <= canvasEl.width + 1 && (zone.y + zone.height) <= canvasEl.height + 1; }
        function checkZoneAndEnableStart() { startTimerBtn.disabled = !(calculateDetectionZoneFromOffsets() && !timerRunning); }
        function setupZoneOffsetSliders() { if (!canvasEl.width || !canvasEl.height) return; [offsetTopSlider, offsetBottomSlider, offsetLeftSlider, offsetRightSlider].forEach(slider => { slider.min = 0; slider.step = 1; slider.removeEventListener('input', handleZoneOffsetSliderChange); slider.addEventListener('input', handleZoneOffsetSliderChange); }); updateOffsetSliderMaxValues(); }
        function updateOffsetSliderMaxValues() { if (!canvasEl.width || !canvasEl.height) return; offsetTopSlider.max = Math.max(0, canvasEl.height - zoneOffsets.bottom - MIN_ZONE_DIMENSION_CANVAS); offsetBottomSlider.max = Math.max(0, canvasEl.height - zoneOffsets.top - MIN_ZONE_DIMENSION_CANVAS); offsetLeftSlider.max = Math.max(0, canvasEl.width - zoneOffsets.right - MIN_ZONE_DIMENSION_CANVAS); offsetRightSlider.max = Math.max(0, canvasEl.width - zoneOffsets.left - MIN_ZONE_DIMENSION_CANVAS); }
        function handleZoneOffsetSliderChange(event) {
            const changedSlider = event.target;
            let newTop = parseInt(offsetTopSlider.value); let newBottom = parseInt(offsetBottomSlider.value);
            let newLeft = parseInt(offsetLeftSlider.value); let newRight = parseInt(offsetRightSlider.value);

            // Constraint: Ensure sum of opposite offsets doesn't make zone too small
            if (newLeft + newRight >= canvasEl.width - MIN_ZONE_DIMENSION_CANVAS) {
                if (changedSlider === offsetLeftSlider) newRight = canvasEl.width - newLeft - MIN_ZONE_DIMENSION_CANVAS;
                else newLeft = canvasEl.width - newRight - MIN_ZONE_DIMENSION_CANVAS;
            }
            if (newTop + newBottom >= canvasEl.height - MIN_ZONE_DIMENSION_CANVAS) {
                if (changedSlider === offsetTopSlider) newBottom = canvasEl.height - newTop - MIN_ZONE_DIMENSION_CANVAS;
                else newTop = canvasEl.height - newBottom - MIN_ZONE_DIMENSION_CANVAS;
            }
            zoneOffsets.top = Math.max(0, newTop); zoneOffsets.bottom = Math.max(0, newBottom);
            zoneOffsets.left = Math.max(0, newLeft); zoneOffsets.right = Math.max(0, newRight);
            updateSlidersFromZoneOffsets(false); calculateDetectionZoneFromOffsets(); drawDetectionZoneOutline(); checkZoneAndEnableStart();
            if (!timerRunning && currentActiveTrackName) { raceData.tracks[currentActiveTrackName].zoneOffsets = {...zoneOffsets}; saveDataToLocalStorage(); }
        }
        function updateSlidersFromZoneOffsets(triggerChangeEvent = true) { updateOffsetSliderMaxValues(); offsetTopSlider.value = zoneOffsets.top; offsetBottomSlider.value = zoneOffsets.bottom; offsetLeftSlider.value = zoneOffsets.left; offsetRightSlider.value = zoneOffsets.right; offsetTopValue.textContent = zoneOffsets.top; offsetBottomValue.textContent = zoneOffsets.bottom; offsetLeftValue.textContent = zoneOffsets.left; offsetRightValue.textContent = zoneOffsets.right; drawDetectionZoneOutline(); checkZoneAndEnableStart(); }
        function drawDetectionZoneOutline() { if (canvasEl.style.width !== videoContainer.offsetWidth + 'px' || canvasEl.style.height !== videoContainer.offsetHeight + 'px') { canvasEl.style.width = videoContainer.offsetWidth + 'px'; canvasEl.style.height = videoContainer.offsetHeight + 'px';} ctx.clearRect(0, 0, canvasEl.width, canvasEl.height); if (calculateDetectionZoneFromOffsets()) { ctx.strokeStyle = 'rgba(40, 167, 69, 0.9)'; ctx.lineWidth = Math.max(2, 3 * (videoContainer.offsetWidth / canvasEl.width)); ctx.strokeRect(detectionZone.x, detectionZone.y, detectionZone.width, detectionZone.height); } }
        const resizeObserver = new ResizeObserver(entries => { for (let entry of entries) { if (entry.target === videoContainer && video.readyState >= video.HAVE_METADATA) { requestAnimationFrame(() => { canvasEl.width = video.videoWidth; canvasEl.height = video.videoHeight; setupZoneOffsetSliders(); updateSlidersFromZoneOffsets(); drawDetectionZoneOutline(); });}}});
        if(videoContainer) resizeObserver.observe(videoContainer);

        function detectMotion() { if (!timerRunning || !detectionZone || !video.videoWidth || video.paused || video.ended) { if(timerRunning) animationFrameId = requestAnimationFrame(detectMotion); return; } if (!isValidZone(detectionZone)) return; const zoneWidth = Math.max(1, Math.floor(detectionZone.width)); const zoneHeight = Math.max(1, Math.floor(detectionZone.height)); const offscreenCanvas = document.createElement('canvas'); const offscreenCtx = offscreenCanvas.getContext('2d', { willReadFrequently: true }); offscreenCanvas.width = zoneWidth; offscreenCanvas.height = zoneHeight; let sourceX = detectionZone.x; if (video.style.transform === 'scaleX(-1)') { sourceX = video.videoWidth - detectionZone.x - detectionZone.width; } offscreenCtx.drawImage(video, sourceX, detectionZone.y, detectionZone.width, detectionZone.height, 0, 0, zoneWidth, zoneHeight); const currentFrameData = offscreenCtx.getImageData(0, 0, zoneWidth, zoneHeight); const currentData = currentFrameData.data; if (prevImageData) { const prevData = prevImageData.data; let changedPixelCount = 0; const totalPixelsInZone = zoneWidth * zoneHeight; for (let i = 0; i < currentData.length; i += 4) { const diffR = Math.abs(currentData[i] - prevData[i]); const diffG = Math.abs(currentData[i+1] - prevData[i+1]); const diffB = Math.abs(currentData[i+2] - prevData[i+2]); if (diffR > PIXEL_INTENSITY_CHANGE_THRESHOLD || diffG > PIXEL_INTENSITY_CHANGE_THRESHOLD || diffB > PIXEL_INTENSITY_CHANGE_THRESHOLD) { changedPixelCount++; } } const percentageChanged = (totalPixelsInZone > 0) ? (changedPixelCount / totalPixelsInZone) * 100 : 0; if (percentageChanged >= CHANGED_PIXELS_PERCENTAGE_TRIGGER) { triggerLap(); ctx.fillStyle = 'rgba(255, 193, 7, 0.5)'; ctx.fillRect(detectionZone.x, detectionZone.y, detectionZone.width, detectionZone.height); setTimeout(() => drawDetectionZoneOutline(), 150); } } prevImageData = currentFrameData; if (timerRunning) animationFrameId = requestAnimationFrame(detectMotion); }
        
        function handleStartTimer() { if (!currentActiveTrackName) { alert("Please select or create a track first."); return; } if (!calculateDetectionZoneFromOffsets()) { statusMessage.textContent = "Please set a valid detection zone first!"; statusMessage.className = "status-message status-warning"; return; } if (timerRunning) return; timerRunning = true; startTimerBtn.disabled = true; stopTimerBtn.disabled = false; resetTimerBtn.disabled = true; sensitivityRange.disabled = true; minLapTimeRange.disabled = true; [offsetTopSlider, offsetBottomSlider, offsetLeftSlider, offsetRightSlider].forEach(s => s.disabled = true); cameraSelect.disabled = true; lapStartTime = performance.now(); if (currentLap === 0) totalStartTime = lapStartTime; lastTriggerTime = performance.now() - MIN_LAP_TIME_MS; statusMessage.textContent = "Timer running! Listening for drone..."; statusMessage.className = "status-message status-success"; prevImageData = null; animationFrameId = requestAnimationFrame(detectMotion); updateTotalTimeDisplay(); }
        function handleStopTimer() { if (!timerRunning) return; timerRunning = false; cancelAnimationFrame(animationFrameId); stopTimerBtn.disabled = true; resetTimerBtn.disabled = false; sensitivityRange.disabled = false; minLapTimeRange.disabled = false; [offsetTopSlider, offsetBottomSlider, offsetLeftSlider, offsetRightSlider].forEach(s => s.disabled = false); cameraSelect.disabled = false; if (lapTimes.length > 0) { saveCurrentSession(); statusMessage.textContent = `Session saved for track: ${currentActiveTrackName}. Adjust zone or start new session.`; } else { statusMessage.textContent = "Timer stopped. No laps to save."; } startTimerBtn.disabled = false; prevImageData = null; statusMessage.className = "status-message status-info"; }
        function handleResetTimer() { if (timerRunning) { timerRunning = false; cancelAnimationFrame(animationFrameId); stopTimerBtn.disabled = true; resetTimerBtn.disabled = false; sensitivityRange.disabled = false; minLapTimeRange.disabled = false; [offsetTopSlider, offsetBottomSlider, offsetLeftSlider, offsetRightSlider].forEach(s => s.disabled = false); cameraSelect.disabled = false; prevImageData = null; } resetCurrentSessionState(); statusMessage.textContent = "Current laps cleared. Adjust zone or start new session."; statusMessage.className = "status-message status-info"; startTimerBtn.disabled = false; checkZoneAndEnableStart(); }
        function resetCurrentSessionState() { currentLap = 0; lapTimes = []; lapStartTime = 0; totalStartTime = 0; updateLapDisplay(); lapTimesList.innerHTML = ''; bestLapTimeDisplay.textContent = "N/A"; best3ConsecutiveDisplay.textContent = "-"; totalTimeDisplay.textContent = "0.000s"; lapCountDisplay.textContent = "0"; lastLapTimeDisplay.textContent = "0.000s"; }

        function saveCurrentSession() { if (!currentActiveTrackName || !raceData.tracks[currentActiveTrackName]) { console.error("Cannot save session: No active track."); return; } if (lapTimes.length === 0) return; const sessionBestLap = (lapTimes.length > 0) ? Math.min(...lapTimes) : null; const sessionBest3 = calculateBest3Consecutive(lapTimes); const newSession = { date: new Date().toISOString(), laps: [...lapTimes], sessionBestLap: sessionBestLap, sessionBest3Consecutive: sessionBest3 }; raceData.tracks[currentActiveTrackName].sessions.push(newSession); raceData.tracks[currentActiveTrackName].zoneOffsets = {...zoneOffsets}; saveDataToLocalStorage(); }
        function calculateBest3Consecutive(lapsArray) { if (!lapsArray || lapsArray.length < 3) return null; let minSum = Infinity; let bestStartIndex = -1; for (let i = 0; i <= lapsArray.length - 3; i++) { const currentSum = lapsArray[i] + lapsArray[i+1] + lapsArray[i+2]; if (currentSum < minSum) { minSum = currentSum; bestStartIndex = i; } } if (bestStartIndex !== -1) { return { total: parseFloat(minSum.toFixed(3)), lapsIndices: [bestStartIndex, bestStartIndex + 1, bestStartIndex + 2], lapTimes: lapsArray.slice(bestStartIndex, bestStartIndex + 3).map(t => parseFloat(t.toFixed(3))) }; } return null; }
        function populateTrackStats() { if (!currentActiveTrackName || !raceData.tracks[currentActiveTrackName]) { trackStatsContent.innerHTML = "<p>No track data available.</p>"; return; } const track = raceData.tracks[currentActiveTrackName]; trackStatsNameDisplay.textContent = `Track Stats for: ${track.name}`; let overallBestLap = Infinity; let overallBest3Total = Infinity; let overallBest3Details = null; let sessionDates = []; let sessionBestLapsData = []; let sessionBest3TotalsData = []; pastSessionsList.innerHTML = ''; if (track.sessions.length === 0) { pastSessionsList.innerHTML = "<li>No sessions recorded for this track yet.</li>"; } track.sessions.sort((a,b) => new Date(b.date) - new Date(a.date)); track.sessions.forEach(session => { if (session.sessionBestLap && session.sessionBestLap < overallBestLap) { overallBestLap = session.sessionBestLap; } if (session.sessionBest3Consecutive && session.sessionBest3Consecutive.total < overallBest3Total) { overallBest3Total = session.sessionBest3Consecutive.total; overallBest3Details = session.sessionBest3Consecutive; } sessionDates.push(new Date(session.date).toLocaleDateString([], {year:'2-digit', month:'2-digit', day: '2-digit'})); sessionBestLapsData.push(session.sessionBestLap); sessionBest3TotalsData.push(session.sessionBest3Consecutive ? session.sessionBest3Consecutive.total : null); const li = document.createElement('li'); let sessionText = `<strong>${new Date(session.date).toLocaleString()}</strong>`; sessionText += `Laps: ${session.laps.length}, Best: ${session.sessionBestLap ? session.sessionBestLap.toFixed(3) + 's' : 'N/A'}<br>`; if (session.sessionBest3Consecutive) { sessionText += `Best 3: ${session.sessionBest3Consecutive.total.toFixed(3)}s (${session.sessionBest3Consecutive.lapTimes.map(t=>t.toFixed(2)).join(', ')})`; } else { sessionText += `Best 3: N/A`; } li.innerHTML = sessionText; pastSessionsList.appendChild(li); }); overallBestLapDisplay.textContent = (overallBestLap === Infinity) ? "N/A" : `${overallBestLap.toFixed(3)}s`; if (overallBest3Details) { overallBest3ConsecutiveDisplay.textContent = `${overallBest3Details.total.toFixed(3)}s (${overallBest3Details.lapTimes.map(t=>t.toFixed(2)).join(', ')})`; } else { overallBest3ConsecutiveDisplay.textContent = "N/A"; } if (typeof Chart !== 'undefined') { if (progressionChartInstance) { progressionChartInstance.destroy(); } const chartCtx = progressionChartCanvas.getContext('2d'); const reversedDates = [...sessionDates].reverse(); const reversedBestLaps = [...sessionBestLapsData].reverse(); const reversedBest3s = [...sessionBest3TotalsData].reverse(); progressionChartInstance = new Chart(chartCtx, { type: 'line', data: { labels: reversedDates, datasets: [ { label: 'Best Lap (s)', data: reversedBestLaps, borderColor: 'rgb(75, 192, 192)', tension: 0.1, fill: false, spanGaps: true }, { label: 'Best 3 Total (s)', data: reversedBest3s, borderColor: 'rgb(255, 99, 132)', tension: 0.1, fill: false, spanGaps: true, yAxisID: 'yBest3' } ] }, options: { responsive: true, maintainAspectRatio: false, legend: { display: true }, tooltips: { mode: 'index', intersect: false }, scales: { yAxes: [ { id: 'yBestLap', type: 'linear', position: 'left', ticks: { beginAtZero: false }, scaleLabel: { display: true, labelString: 'Best Lap Time (s)'} }, { id: 'yBest3', type: 'linear', position: 'right', ticks: { beginAtZero: false }, scaleLabel: { display: true, labelString: 'Best 3 Laps Total (s)'}, gridLines: { drawOnChartArea: false } } ], xAxes: [{ scaleLabel: { display: true, labelString: 'Session Date' } }] } } }); document.querySelector("#progressionChartContainer p").style.display = 'none'; } else { document.querySelector("#progressionChartContainer p").style.display = 'block'; } }

        function triggerLap() { const now = performance.now(); if (now - lastTriggerTime < MIN_LAP_TIME_MS) { return; } lastTriggerTime = now; if (currentLap > 0 || lapTimes.length > 0) { const lapTime = (now - lapStartTime) / 1000; lapTimes.push(lapTime); } else if (currentLap === 0 && lapTimes.length === 0) { totalStartTime = now; } currentLap++; lapStartTime = now; updateLapDisplay(); speakLapTime(); }
        function updateTotalTimeDisplay() { if (timerRunning) { const elapsed = (performance.now() - totalStartTime) / 1000; totalTimeDisplay.textContent = elapsed.toFixed(3) + 's'; if(timerRunning) requestAnimationFrame(updateTotalTimeDisplay); } else if (lapTimes.length > 0) { const sumOfLaps = lapTimes.reduce((sum, t) => sum + t, 0); totalTimeDisplay.textContent = sumOfLaps.toFixed(3) + 's'; } else { totalTimeDisplay.textContent = "0.000s"; } }
        function updateLapDisplay() { lapCountDisplay.textContent = currentLap; if (lapTimes.length > 0) { const lastLap = lapTimes[lapTimes.length - 1]; lastLapTimeDisplay.textContent = lastLap.toFixed(3) + 's'; const li = document.createElement('li'); li.textContent = `Lap ${lapTimes.length}: ${lastLap.toFixed(3)}s`; lapTimesList.prepend(li); updateLiveBestLap(); updateLiveBest3Consecutive(); } else { lastLapTimeDisplay.textContent = "0.000s"; } updateTotalTimeDisplay(); }
        function updateLiveBestLap() { if (lapTimes.length === 0) { bestLapTimeDisplay.textContent = "N/A"; return; } const best = Math.min(...lapTimes); bestLapTimeDisplay.textContent = best.toFixed(3) + 's'; const lis = lapTimesList.getElementsByTagName('li'); for (let li of lis) { li.classList.remove('best-lap'); if (Math.abs(parseFloat(li.textContent.split(': ')[1]) - best) < 0.0001) { li.classList.add('best-lap'); } } }
        function updateLiveBest3Consecutive() { const best3 = calculateBest3Consecutive(lapTimes); if (best3) { best3ConsecutiveDisplay.textContent = `${best3.total.toFixed(3)}s (${best3.lapTimes.map(t=>t.toFixed(2)).join(', ')})`; } else { best3ConsecutiveDisplay.textContent = "-"; } }
        function speakLapTime() { if (lapTimes.length > 0 && 'speechSynthesis' in window) { const lastLap = lapTimes[lapTimes.length - 1]; const timeStr = lastLap.toFixed(2).replace('.', ' point '); const utterance = new SpeechSynthesisUtterance(`Lap ${lapTimes.length}. ${timeStr} seconds.`); speechSynthesis.speak(utterance); } }
        
        initApp();
    </script>
</body>
</html>