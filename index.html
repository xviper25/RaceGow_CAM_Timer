<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Racegow FPV Lap Timer</title>
    <style>
        :root {
            --primary-color: #007bff;
            --secondary-color: #6c757d;
            --background-color: #f0f2f5;
            --surface-color: #ffffff;
            --text-color: #333;
            --success-color: #28a745;
            --warning-color: #ffc107;
            --danger-color: #dc3545;
            --font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            
            --zone-selector-bg: rgba(0, 123, 255, 0.20); /* Light blue, semi-transparent */
            --zone-selector-border: rgba(0, 123, 255, 0.7);
             /* Increase handle size for touch */
            --zone-handle-size: 14px;
            --zone-handle-bg: #007bff;
        }

        body {
            font-family: var(--font-family);
            margin: 0;
            padding: 0;
            background-color: var(--background-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            overscroll-behavior: none; /* Prevent pull-to-refresh etc. */
        }
         /* Prevent ALL scrolling and gestures on the body when interacting */
        body.zone-interaction-active {
             overflow: hidden;
        }

        .container {
            width: 100%;
            max-width: 600px;
            padding: 15px;
            box-sizing: border-box;
        }

        header {
            background-color: var(--primary-color);
            color: white;
            padding: 15px;
            text-align: center;
            font-size: 1.5em;
            font-weight: bold;
            width: 100%;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 15px;
        }
        header h1 { margin: 0; font-size: 1.2em; }

        .video-container {
            position: relative;
            width: 100%;
            background-color: #000;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            user-select: none; 
            -webkit-user-select: none;
             -ms-user-select: none;
             -webkit-touch-callout: none; /* Disable touch-and-hold menu */
        }

        #videoFeed {
            width: 100%;
            display: block;
            transform: scaleX(-1);
             pointer-events: none; /* Ensure video doesn't eat events */
        }

        #detectionCanvas { /* For the final green outline */
            position: absolute;
            top: 0;
            left: 0;
            width: 100%; 
            height: 100%;
            pointer-events: none;
        }

        #zoneSelectorDiv { /* Interactive DIV for setting the zone */
            position: absolute;
            background-color: var(--zone-selector-bg);
            border: 2px solid var(--zone-selector-border);
            box-sizing: border-box;
            cursor: move;
            z-index: 10; 
            display: none; /* Hidden initially */
            touch-action: none; /* IMPORTANT: Prevent browser gestures on the zone itself */
        }

        .resize-handle {
            position: absolute;
            width: var(--zone-handle-size);
            height: var(--zone-handle-size);
            background-color: var(--zone-handle-bg);
            border: 1px solid white;
            border-radius: 3px; 
            box-sizing: border-box;
            z-index: 11;
            touch-action: none; /* IMPORTANT: Prevent browser gestures on handles */
        }
        /* Position handles half-way out to make grabbing corners easier */
        .handle-nw { top: calc(var(--zone-handle-size) / -2); left: calc(var(--zone-handle-size) / -2); cursor: nwse-resize; }
        .handle-ne { top: calc(var(--zone-handle-size) / -2); right: calc(var(--zone-handle-size) / -2); cursor: nesw-resize; }
        .handle-sw { bottom: calc(var(--zone-handle-size) / -2); left: calc(var(--zone-handle-size) / -2); cursor: nesw-resize; }
        .handle-se { bottom: calc(var(--zone-handle-size) / -2); right: calc(var(--zone-handle-size) / -2); cursor: nwse-resize; }
        .handle-n { top: calc(var(--zone-handle-size) / -2); left: 50%; transform: translateX(-50%); cursor: ns-resize; }
        .handle-s { bottom: calc(var(--zone-handle-size) / -2); left: 50%; transform: translateX(-50%); cursor: ns-resize; }
        .handle-w { top: 50%; left: calc(var(--zone-handle-size) / -2); transform: translateY(-50%); cursor: ew-resize; }
        .handle-e { top: 50%; right: calc(var(--zone-handle-size) / -2); transform: translateY(-50%); cursor: ew-resize; }
        
        #zoneInstructionOverlay {
            position: absolute;
            bottom: 10px; 
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0,0,0,0.7);
            color: white;
            padding: 8px 15px;
            border-radius: 5px;
            font-size: 0.9em;
            text-align: center;
            z-index: 20;
            display: none; 
            pointer-events: none;
            transition: opacity 0.4s ease-out;
        }

       /* --- Styles for Controls, Stats, Laps, Session --- */
       /* (These are unchanged from your previous version) */
       .controls, .session-controls, .stats-display, .lap-list-container { background-color: var(--surface-color); padding: 15px; margin-bottom: 15px; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
       .controls h2, .session-controls h2, .stats-display h2, .lap-list-container h2 { margin-top: 0; font-size: 1.2em; color: var(--primary-color); border-bottom: 1px solid #eee; padding-bottom: 8px; }
       button { background-color: var(--primary-color); color: white; border: none; padding: 10px 15px; margin: 5px; border-radius: 5px; cursor: pointer; font-size: 1em; transition: background-color 0.2s ease; }
       button:hover:not(:disabled) { background-color: #0056b3; }
       button:disabled { background-color: var(--secondary-color); cursor: not-allowed; }
       .btn-success { background-color: var(--success-color); }
       .btn-success:hover:not(:disabled) { background-color: #1e7e34; }
       .btn-warning { background-color: var(--warning-color); color: #333; }
       .btn-warning:hover:not(:disabled) { background-color: #d39e00; }
       .btn-danger { background-color: var(--danger-color); }
       .btn-danger:hover:not(:disabled) { background-color: #bd2130; }
       input[type="text"], input[type="range"] { padding: 8px; margin: 5px 0; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box; width: calc(100% - 10px); }
       .slider-container { display: flex; align-items: center; margin-bottom: 10px; }
       .slider-container label { margin-right: 10px; white-space: nowrap; }
       .slider-container input[type="range"] { flex-grow: 1; }
       .slider-container span { min-width: 30px; text-align: right; }
       #lapTimesList { list-style-type: none; padding: 0; max-height: 200px; overflow-y: auto; border: 1px solid #eee; border-radius: 4px; }
       #lapTimesList li { padding: 8px 10px; border-bottom: 1px solid #eee; }
       #lapTimesList li:last-child { border-bottom: none; }
       #lapTimesList li.best-lap { background-color: #e6ffed; font-weight: bold; }
       .status-message { padding: 10px; margin-bottom: 15px; border-radius: 5px; text-align: center; }
       .status-info { background-color: #e7f3fe; color: #0c5460; border: 1px solid #b8daff;}
       .status-error { background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6cb;}
       .status-warning { background-color: #fff3cd; color: #856404; border: 1px solid #ffeeba; }
       .status-success { background-color: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
       .flex-controls { display: flex; flex-wrap: wrap; justify-content: space-around; }
       .flex-controls button { flex-grow: 1; margin: 5px; }
       .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 10px; text-align: center; }
       .stat-item { background-color: #f9f9f9; padding: 10px; border-radius: 5px; border: 1px solid #eee; }
       .stat-item .label { font-size: 0.8em; color: var(--secondary-color); display: block; margin-bottom: 5px; }
       .stat-item .value { font-size: 1.4em; font-weight: bold; color: var(--primary-color); }
       .stat-item .value.small { font-size: 1em; }

    </style>
</head>
<body>
     <header><h1>Racegow FPV Lap Timer</h1></header>

    <div class="container">
        <div id="statusMessage" class="status-message status-info">Initializing camera...</div>

        <div class="video-container">
             <!-- HTML unchanged -->
            <video id="videoFeed" playsinline autoplay muted></video>
            <canvas id="detectionCanvas"></canvas>
            <div id="zoneSelectorDiv">
                <div class="resize-handle handle-nw" data-handle="nw"></div> <div class="resize-handle handle-ne" data-handle="ne"></div>
                <div class="resize-handle handle-sw" data-handle="sw"></div> <div class="resize-handle handle-se" data-handle="se"></div>
                <div class="resize-handle handle-n" data-handle="n"></div>   <div class="resize-handle handle-s" data-handle="s"></div>
                <div class="resize-handle handle-w" data-handle="w"></div>   <div class="resize-handle handle-e" data-handle="e"></div>
            </div>
            <div id="zoneInstructionOverlay">Adjust zone to cover finish line. Drag to move, use handles to resize.</div>
        </div>

        <div class="controls">
             <!-- HTML unchanged -->
            <h2>Timer Controls</h2>
            <div class="flex-controls">
                <button id="startTimerBtn" class="btn-success" disabled>Start Timer</button>
                <button id="stopTimerBtn" disabled class="btn-danger">Stop Timer</button>
                <button id="resetTimerBtn" class="btn-warning">Reset All</button>
            </div>
            <div class="slider-container">
                <label for="sensitivityRange">Sensitivity:</label>
                <input type="range" id="sensitivityRange" min="5" max="50" value="20"><span id="sensitivityValue">20</span>
             </div>
             <div class="slider-container">
                 <label for="minLapTimeRange">Min Lap (s):</label>
                <input type="range" id="minLapTimeRange" min="0.5" max="5" step="0.1" value="1.0"><span id="minLapTimeValue">1.0</span>
            </div>
        </div>
        
        <div class="stats-display"> <!-- HTML unchanged -->
            <h2>Live Stats</h2>
            <div class="stats-grid">
                <div class="stat-item"><span class="label">Current Lap</span><span class="value" id="lapCount">0</span></div>
                <div class="stat-item"><span class="label">Last Lap</span><span class="value" id="lastLapTime">0.000s</span></div>
                <div class="stat-item"><span class="label">Best Lap</span><span class="value" id="bestLapTime">N/A</span></div>
             </div>
             <div class="stat-item" style="margin-top:10px;"><span class="label">Best 3 Consecutive</span><span class="value small" id="best3Consecutive">-</span></div>
             <div class="stat-item"><span class="label">Total Time</span><span class="value" id="totalTime">0.000s</span></div>
        </div>

         <div class="lap-list-container"> <!-- HTML unchanged -->
            <h2>Lap Times</h2>
            <ul id="lapTimesList"></ul>
        </div>

        <div class="session-controls"> <!-- HTML unchanged -->
            <h2>Session Management</h2>
            <input type="text" id="sessionName" placeholder="Enter session name (e.g., Track A - Evening)"><button id="saveSessionBtn">Save Laps</button><button id="loadSessionBtn">Load Last Session</button>
            <p style="font-size: 0.8em; color: var(--secondary-color);">Sessions are saved in your browser's cookies.</p>
        </div>
    </div>

    <script>
        // --- GET ELEMENTS (Unchanged) ---
        const video = document.getElementById('videoFeed');
        const videoContainer = document.querySelector('.video-container');
        const canvasEl = document.getElementById('detectionCanvas');
        const ctx = canvasEl.getContext('2d', { willReadFrequently: true });
        const zoneSelectorDiv = document.getElementById('zoneSelectorDiv');
        const zoneInstructionOverlay = document.getElementById('zoneInstructionOverlay');
        const startTimerBtn = document.getElementById('startTimerBtn');
        const stopTimerBtn = document.getElementById('stopTimerBtn');
        const resetTimerBtn = document.getElementById('resetTimerBtn');
        const statusMessage = document.getElementById('statusMessage');
        // ... other getters
        const sensitivityRange = document.getElementById('sensitivityRange');
        const sensitivityValue = document.getElementById('sensitivityValue');
        const minLapTimeRange = document.getElementById('minLapTimeRange');
        const minLapTimeValue = document.getElementById('minLapTimeValue');
        const lapCountDisplay = document.getElementById('lapCount');
        const lastLapTimeDisplay = document.getElementById('lastLapTime');
        const bestLapTimeDisplay = document.getElementById('bestLapTime');
        const totalTimeDisplay = document.getElementById('totalTime');
        const best3ConsecutiveDisplay = document.getElementById('best3Consecutive');
        const lapTimesList = document.getElementById('lapTimesList');
        const sessionNameInput = document.getElementById('sessionName');
        const saveSessionBtn = document.getElementById('saveSessionBtn');
        const loadSessionBtn = document.getElementById('loadSessionBtn');

        // --- STATE VARIABLES (Unchanged) ---
        let stream;
        let detectionZone = { x: 0, y: 0, width: 0, height: 0 }; 
        let isInteractingWithZone = false;
        let interactionType = null; 
        let pointerStart = { x: 0, y: 0 }; 
        let zoneStart = { x: 0, y: 0, width: 0, height: 0 };
        let timerRunning = false;
        let lapStartTime = 0;
        let currentLap = 0;
        let lapTimes = [];
        let lastTriggerTime = 0;
        let animationFrameId;
        let prevImageData = null;
        let totalStartTime = 0;
        const MOTION_THRESHOLD_BASE = 20;
        let MIN_LAP_TIME_MS = 1000;
        const MIN_ZONE_DIMENSION_CANVAS = 30; 

        //-----------------------------------------------------------------
        // --- CORE LOGIC ---
        //-----------------------------------------------------------------
        
        async function init() {
            try {
                stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' } });
                video.srcObject = stream;
                // We MUST wait for the video to actually start playing to be sure
                await video.play(); 
                 
                video.onloadedmetadata = () => {
                   // console.log("Video Metadata Loaded.");
                    canvasEl.width = video.videoWidth;
                    canvasEl.height = video.videoHeight;
                   
                    loadDetectionZoneFromCookie(); 
                    if (!isValidZone(detectionZone)) { 
                         setDefaultZone();
                    }
                    
                    // Use requestAnimationFrame to ensure layout is complete before drawing
                    requestAnimationFrame( () => {
                        showZoneSelector(); // This now makes visible, positions, and draws
                        statusMessage.textContent = "Adjust zone, then start timer.";
                        statusMessage.className = "status-message status-info";
                        checkZoneAndEnableStart();
                    });
                };
                 video.onerror = (e) => handleError("Video error. Check permissions or try another browser.");

            } catch (err) {
                 // Error handling (same as before, good)
                console.error("getUserMedia error:", err);
                 if (err.name === "NotAllowedError" || err.name === "PermissionDeniedError") {
                    handleError("Camera access denied. Please enable it in your browser settings and refresh.");
                } else if (err.name === "NotFoundError" || err.name === "DevicesNotFoundError"){
                    handleError("No camera found. Ensure a camera is connected and enabled.");
                } else {
                    handleError(`Camera Error: ${err.name}. Please refresh or check settings.`);
                }
            }
            setupZoneInteractions();
             // Initialize sliders
            MIN_LAP_TIME_MS = parseFloat(minLapTimeRange.value) * 1000;
            minLapTimeValue.textContent = parseFloat(minLapTimeRange.value).toFixed(1);
            sensitivityValue.textContent = sensitivityRange.value;
        }

        function handleError(message) { /* Unchanged */
             statusMessage.textContent = message; statusMessage.className = "status-message status-error";
             startTimerBtn.disabled = true; zoneSelectorDiv.style.display = 'none'; zoneInstructionOverlay.style.display = 'none';
        }
         
        function setDefaultZone() {
             const insetRatio = 0.25; 
             detectionZone.width = canvasEl.width * (1 - 2 * insetRatio);
             detectionZone.height = canvasEl.height * (1 - 2 * insetRatio);
             detectionZone.x = (canvasEl.width - detectionZone.width) / 2;
             detectionZone.y = (canvasEl.height - detectionZone.height) / 2;
        }

        function isValidZone(zone) { /* Unchanged */
             return zone && zone.width >= MIN_ZONE_DIMENSION_CANVAS && zone.height >= MIN_ZONE_DIMENSION_CANVAS &&
                   zone.x >= 0 && zone.y >= 0 &&
                   (zone.x + zone.width) <= canvasEl.width + 1 && 
                   (zone.y + zone.height) <= canvasEl.height + 1;
        }
         
        function checkZoneAndEnableStart() { /* Unchanged */
            startTimerBtn.disabled = !(isValidZone(detectionZone) && !timerRunning);
        }

        function showZoneSelector() {
           // console.log("Showing Zone Selector");
            updateZoneSelectorFromDetectionZone(); // Position the DIV based on data
            drawDetectionZoneOutline(); // Draw on Canvas
            zoneSelectorDiv.style.display = 'block'; // Make it visible
            
            zoneInstructionOverlay.style.display = 'block';
            zoneInstructionOverlay.style.opacity = 1;
            setTimeout(() => { zoneInstructionOverlay.style.opacity = 0; setTimeout(()=>zoneInstructionOverlay.style.display='none', 500)}, 4000);
        }

        // --- Zone Selector DIV Interaction ---
        function setupZoneInteractions() {
             // Attach to the container, NOT the div, initially,
             // Then check if the target is the zone div or a handle.
             // This can sometimes be more robust. However, attaching
             // to the div directly and using document for move/up is standard.
             // Ensuring passive:false is the key.
            zoneSelectorDiv.addEventListener('mousedown', onPointerDownZone);
            zoneSelectorDiv.addEventListener('touchstart', onPointerDownZone, { passive: false }); // *** Explicitly NOT passive
            
            document.addEventListener('mousemove', onPointerMoveZone);
            document.addEventListener('touchmove', onPointerMoveZone, { passive: false }); // *** Explicitly NOT passive

            document.addEventListener('mouseup', onPointerUpZone);
            document.addEventListener('touchend', onPointerUpZone);
            document.addEventListener('touchcancel', onPointerUpZone); // Important
        }

        function onPointerDownZone(event) {
            if (timerRunning) return;
           
            // IMPORTANT: Prevent default ONLY if we are actually interacting with the zone/handles
            // to allow scrolling on the page if the touch starts elsewhere.
             const target = event.target;
             if (target.closest("#zoneSelectorDiv")) {
                // Only call preventDefault IF the touch actually starts on our interactive element
                 if (event.type === 'touchstart') event.preventDefault(); 
             } else {
                 return; // Don't start interaction if click/touch wasn't on the selector
             }

            isInteractingWithZone = true;
            document.body.classList.add('zone-interaction-active'); // Helps disable body scroll

            zoneInstructionOverlay.style.display = 'none'; 

            pointerStart.x = (event.type === 'touchstart') ? event.touches[0].clientX : event.clientX;
            pointerStart.y = (event.type === 'touchstart') ? event.touches[0].clientY : event.clientY;
            zoneStart = { ...detectionZone }; 

            if (target.classList.contains('resize-handle')) {
                interactionType = target.dataset.handle;
            } else {
                interactionType = 'move';
            }
             // console.log("Pointer Down:", interactionType);
        }

        function onPointerMoveZone(event) {
            if (!isInteractingWithZone || timerRunning) return;
            
             // We already set passive:false on the listener,
             // so preventDefault() should work here to stop scroll during drag.
            event.preventDefault(); 
            
            const currentX = (event.type === 'touchmove') ? event.touches[0].clientX : event.clientX;
            const currentY = (event.type === 'touchmove') ? event.touches[0].clientY : event.clientY;

            let dxViewport = currentX - pointerStart.x;
            let dyViewport = currentY - pointerStart.y;

            const videoRect = videoContainer.getBoundingClientRect();
            // FIX: Ensure we don't divide by zero if container isn't rendered
            const scaleW = (videoRect.width > 0) ? (canvasEl.width / videoRect.width) : 0;
            const scaleH = (videoRect.height > 0) ? (canvasEl.height / videoRect.height) : 0;
           
            const dxCanvas = dxViewport * scaleW;
            const dyCanvas = dyViewport * scaleH;
            
            let newX = zoneStart.x; let newY = zoneStart.y;
            let newWidth = zoneStart.width; let newHeight = zoneStart.height;

             // Resize/Move logic (Unchanged - was logically sound)
            if (interactionType === 'move') {
                newX += dxCanvas; newY += dyCanvas;
            } else { 
                if (interactionType.includes('w')) { newX += dxCanvas; newWidth -= dxCanvas; }
                if (interactionType.includes('e')) { newWidth += dxCanvas; }
                if (interactionType.includes('n')) { newY += dyCanvas; newHeight -= dyCanvas; }
                if (interactionType.includes('s')) { newHeight += dyCanvas; }
            }
            if (newWidth < MIN_ZONE_DIMENSION_CANVAS) {
                if (interactionType.includes('w')) newX = zoneStart.x + zoneStart.width - MIN_ZONE_DIMENSION_CANVAS;
                newWidth = MIN_ZONE_DIMENSION_CANVAS;
            }
            if (newHeight < MIN_ZONE_DIMENSION_CANVAS) {
                 if (interactionType.includes('n')) newY = zoneStart.y + zoneStart.height - MIN_ZONE_DIMENSION_CANVAS;
                newHeight = MIN_ZONE_DIMENSION_CANVAS;
            }
            newX = Math.max(0, Math.min(newX, canvasEl.width - newWidth));
            newY = Math.max(0, Math.min(newY, canvasEl.height - newHeight));
            newWidth = Math.min(newWidth, canvasEl.width - newX);
            newHeight = Math.min(newHeight, canvasEl.height - newY);

            detectionZone.x = Math.round(newX); detectionZone.y = Math.round(newY);
            detectionZone.width = Math.round(newWidth); detectionZone.height = Math.round(newHeight);

            updateZoneSelectorFromDetectionZone();
            drawDetectionZoneOutline();
            checkZoneAndEnableStart();
        }

        function onPointerUpZone(event) {
            if (!isInteractingWithZone) return;
            isInteractingWithZone = false;
             document.body.classList.remove('zone-interaction-active');
            interactionType = null;
            saveDetectionZoneToCookie();
            checkZoneAndEnableStart(); 
           // console.log("Pointer Up. Zone:", detectionZone);
        }

        function updateZoneSelectorFromDetectionZone() { /* Unchanged */
            if (!videoContainer.offsetWidth) return; 
            const videoRect = videoContainer.getBoundingClientRect();
            const displayX = (detectionZone.x / canvasEl.width) * videoRect.width;
            const displayY = (detectionZone.y / canvasEl.height) * videoRect.height;
            const displayWidth = (detectionZone.width / canvasEl.width) * videoRect.width;
            const displayHeight = (detectionZone.height / canvasEl.height) * videoRect.height;
            zoneSelectorDiv.style.left = `${displayX}px`; zoneSelectorDiv.style.top = `${displayY}px`;
            zoneSelectorDiv.style.width = `${displayWidth}px`; zoneSelectorDiv.style.height = `${displayHeight}px`;
        }

        function drawDetectionZoneOutline() { /* Unchanged */
             if (canvasEl.style.width !== videoContainer.offsetWidth + 'px' || canvasEl.style.height !== videoContainer.offsetHeight + 'px') {
                canvasEl.style.width = videoContainer.offsetWidth + 'px';
                canvasEl.style.height = videoContainer.offsetHeight + 'px';
            }
            ctx.clearRect(0, 0, canvasEl.width, canvasEl.height);
            if (isValidZone(detectionZone)) {
                ctx.strokeStyle = 'rgba(40, 167, 69, 0.9)'; 
                ctx.lineWidth = Math.max(2, 4 * (videoContainer.offsetWidth / canvasEl.width));
                ctx.strokeRect(detectionZone.x, detectionZone.y, detectionZone.width, detectionZone.height);
            }
        }

         // Resize Observer (Unchanged)
        const resizeObserver = new ResizeObserver(entries => {
            for (let entry of entries) {
                if (entry.target === videoContainer && video.readyState >= video.HAVE_METADATA) {
                   requestAnimationFrame(() => { // Defer to ensure layout is done
                       updateZoneSelectorFromDetectionZone();
                       drawDetectionZoneOutline();
                   });
                }
            }
        });
         if(videoContainer) resizeObserver.observe(videoContainer);

        // --- TIMER AND LAP LOGIC ---
        // (Motion Detection, Start, Stop, Reset, Lap updates, Cookies, etc.)
        // --- NO CHANGES NEEDED HERE FROM PREVIOUS VERSION ---
        function detectMotion() {
            if (!timerRunning || !detectionZone || !video.videoWidth || video.paused || video.ended) {
                if(timerRunning) animationFrameId = requestAnimationFrame(detectMotion);
                return;
            }
            const zoneWidthForProcessing = Math.max(1, Math.floor(detectionZone.width));
            const zoneHeightForProcessing = Math.max(1, Math.floor(detectionZone.height));
            const offscreenCanvas = document.createElement('canvas');
            const offscreenCtx = offscreenCanvas.getContext('2d', { willReadFrequently: true });
            offscreenCanvas.width = zoneWidthForProcessing;
            offscreenCanvas.height = zoneHeightForProcessing;
            const sourceX = video.videoWidth - detectionZone.x - detectionZone.width;
            offscreenCtx.drawImage(video, sourceX, detectionZone.y, detectionZone.width, detectionZone.height, 0, 0, zoneWidthForProcessing, zoneHeightForProcessing);
            const currentFrameData = offscreenCtx.getImageData(0, 0, zoneWidthForProcessing, zoneHeightForProcessing);
            if (prevImageData) {
                let diff = 0;
                for (let i = 0; i < currentFrameData.data.length; i += 4) {
                    diff += Math.abs(currentFrameData.data[i] - prevImageData.data[i]);
                    diff += Math.abs(currentFrameData.data[i+1] - prevImageData.data[i+1]);
                    diff += Math.abs(currentFrameData.data[i+2] - prevImageData.data[i+2]);
                }
                const avgDiff = diff / (currentFrameData.data.length / 4);
                const motionThreshold = MOTION_THRESHOLD_BASE * ( (55 - parseInt(sensitivityRange.value)) / 30 );
                if (avgDiff > motionThreshold) {
                    triggerLap();
                    ctx.fillStyle = 'rgba(255, 193, 7, 0.5)'; 
                    ctx.fillRect(detectionZone.x, detectionZone.y, detectionZone.width, detectionZone.height);
                    setTimeout(() => drawDetectionZoneOutline(), 150);
                }
            }
            prevImageData = currentFrameData;
            if (timerRunning) animationFrameId = requestAnimationFrame(detectMotion);
        }
        startTimerBtn.addEventListener('click', () => {
            if (!isValidZone(detectionZone)) { statusMessage.textContent = "Please set a valid detection zone first!"; statusMessage.className = "status-message status-warning"; return; }
            if (timerRunning) return;
            timerRunning = true;
            startTimerBtn.disabled = true; stopTimerBtn.disabled = false; resetTimerBtn.disabled = true;
            sensitivityRange.disabled = true; minLapTimeRange.disabled = true;
            zoneSelectorDiv.style.display = 'none'; 
            lapStartTime = performance.now();
            if (currentLap === 0) totalStartTime = lapStartTime;
            lastTriggerTime = performance.now() - MIN_LAP_TIME_MS;
            statusMessage.textContent = "Timer running! Listening for drone..."; statusMessage.className = "status-message status-success";
            prevImageData = null;
            animationFrameId = requestAnimationFrame(detectMotion);
            updateTotalTimeDisplay();
        });
        stopTimerBtn.addEventListener('click', () => {
            if (!timerRunning) return;
            timerRunning = false;
            cancelAnimationFrame(animationFrameId);
            stopTimerBtn.disabled = true; resetTimerBtn.disabled = false;
            sensitivityRange.disabled = false; minLapTimeRange.disabled = false;
            showZoneSelector(); // Re-show and position
            checkZoneAndEnableStart();
            prevImageData = null;
            statusMessage.textContent = "Timer stopped. Adjust zone or start again."; statusMessage.className = "status-message status-info";
        });
         resetTimerBtn.addEventListener('click', () => {
            if (timerRunning) stopTimerBtn.click(); 
            currentLap = 0; lapTimes = []; lapStartTime = 0; totalStartTime = 0; prevImageData = null;
            updateLapDisplay(); 
            lapTimesList.innerHTML = ''; bestLapTimeDisplay.textContent = "N/A"; best3ConsecutiveDisplay.textContent = "-";
            totalTimeDisplay.textContent = "0.000s"; lapCountDisplay.textContent = "0"; lastLapTimeDisplay.textContent = "0.000s";
            sessionNameInput.value = '';
            setDefaultZone(); // Reset to default position/size
            showZoneSelector(); // Show, position, draw
            saveDetectionZoneToCookie(); 
            statusMessage.textContent = "Timer reset. Adjust zone and start."; statusMessage.className = "status-message status-info";
            checkZoneAndEnableStart();
        });
       function triggerLap() { /* Unchanged */
            const now = performance.now(); if (now - lastTriggerTime < MIN_LAP_TIME_MS) { return; }
            lastTriggerTime = now;
            if (currentLap > 0 || lapTimes.length > 0) { const lapTime = (now - lapStartTime) / 1000; lapTimes.push(lapTime);
            } else if (currentLap === 0 && lapTimes.length === 0) { totalStartTime = now; }
            currentLap++; lapStartTime = now; updateLapDisplay(); speakLapTime();
        }
        function updateTotalTimeDisplay() { /* Unchanged */
            if (timerRunning) { const elapsed = (performance.now() - totalStartTime) / 1000; totalTimeDisplay.textContent = elapsed.toFixed(3) + 's'; if(timerRunning) requestAnimationFrame(updateTotalTimeDisplay);
            } else if (lapTimes.length > 0) { const sumOfLaps = lapTimes.reduce((sum, t) => sum + t, 0); totalTimeDisplay.textContent = sumOfLaps.toFixed(3) + 's';
            } else { totalTimeDisplay.textContent = "0.000s"; }
        }
        function updateLapDisplay() { /* Unchanged */
            lapCountDisplay.textContent = currentLap;
            if (lapTimes.length > 0) { const lastLap = lapTimes[lapTimes.length - 1]; lastLapTimeDisplay.textContent = lastLap.toFixed(3) + 's';
                const li = document.createElement('li'); li.textContent = `Lap ${lapTimes.length}: ${lastLap.toFixed(3)}s`; lapTimesList.prepend(li);
                updateBestLap(); updateBest3Consecutive();
            } else { lastLapTimeDisplay.textContent = "0.000s"; }
            updateTotalTimeDisplay();
        }
       function updateBestLap() { /* Unchanged */
            if (lapTimes.length === 0) { bestLapTimeDisplay.textContent = "N/A"; return; }
            const best = Math.min(...lapTimes); bestLapTimeDisplay.textContent = best.toFixed(3) + 's';
            const lis = lapTimesList.getElementsByTagName('li');
            for (let li of lis) { li.classList.remove('best-lap'); if (Math.abs(parseFloat(li.textContent.split(': ')[1]) - best) < 0.0001) { li.classList.add('best-lap'); } }
        }
        function updateBest3Consecutive() { /* Unchanged */
            if (lapTimes.length < 3) { best3ConsecutiveDisplay.textContent = "-"; return; }
            let minSum = Infinity; let bestStartIndex = -1;
            for (let i = 0; i <= lapTimes.length - 3; i++) { const currentSum = lapTimes[i] + lapTimes[i+1] + lapTimes[i+2]; if (currentSum < minSum) { minSum = currentSum; bestStartIndex = i; } }
            if (bestStartIndex !== -1) { const laps = lapTimes.slice(bestStartIndex, bestStartIndex + 3); best3ConsecutiveDisplay.textContent = `Laps ${bestStartIndex + 1}-${bestStartIndex + 3}: ${minSum.toFixed(3)}s (${laps.map(t => t.toFixed(2)).join(', ')})`;
            } else { best3ConsecutiveDisplay.textContent = "-"; }
        }
       function speakLapTime() { /* Unchanged */
            if (lapTimes.length > 0 && 'speechSynthesis' in window) {
                const lastLap = lapTimes[lapTimes.length - 1]; const timeStr = lastLap.toFixed(2).replace('.', ' point ');
                const utterance = new SpeechSynthesisUtterance(`Lap ${lapTimes.length}. ${timeStr} seconds.`);
                speechSynthesis.speak(utterance);
            }
        }
        sensitivityRange.addEventListener('input', (e) => sensitivityValue.textContent = e.target.value);
        minLapTimeRange.addEventListener('input', (e) => { minLapTimeValue.textContent = parseFloat(e.target.value).toFixed(1); MIN_LAP_TIME_MS = parseFloat(e.target.value) * 1000; });
       function saveDetectionZoneToCookie() { /* Unchanged */
            if (detectionZone && isValidZone(detectionZone)) { document.cookie = `racegow_detectionZone=${JSON.stringify(detectionZone)};max-age=31536000;path=/;samesite=Lax`; }
        }
       function loadDetectionZoneFromCookie() { /* Unchanged */
            const cookies = document.cookie.split(';');
            for (let cookie of cookies) { const [name, value] = cookie.trim().split('='); if (name === 'racegow_detectionZone') {
                    try { const parsedZone = JSON.parse(value);
                        if (isValidZone(parsedZone)) { detectionZone = parsedZone; }
                    } catch (e) { console.error("Error parsing zone cookie:", e); }
                    return;  } }
        }
       saveSessionBtn.addEventListener('click', () => { /* Unchanged */ 
            const sessionName = sessionNameInput.value.trim() || `Session ${new Date().toLocaleString()}`; if (lapTimes.length === 0) { alert("No laps to save!"); return; }
            const sessionData = { name: sessionName, laps: lapTimes, date: new Date().toISOString() };
            document.cookie = `racegow_lastSession=${JSON.stringify(sessionData)};max-age=31536000;path=/;samesite=Lax`; alert(`Session "${sessionName}" saved!`);
        });
       loadSessionBtn.addEventListener('click', () => { /* Unchanged */
             const cookies = document.cookie.split(';');
            for (let cookie of cookies) { const [name, value] = cookie.trim().split('='); if (name === 'racegow_lastSession') {
                    try { const sessionData = JSON.parse(value); if (sessionData && sessionData.laps) {
                            if (timerRunning) stopTimerBtn.click();
                            lapTimes = sessionData.laps; sessionNameInput.value = sessionData.name || "Loaded Session"; currentLap = lapTimes.length;
                            lapTimesList.innerHTML = ''; lapTimes.forEach((lapTime, index) => { const li = document.createElement('li'); li.textContent = `Lap ${index + 1}: ${lapTime.toFixed(3)}s`; lapTimesList.prepend(li); });
                            const items = Array.from(lapTimesList.childNodes); items.reverse().forEach(item => lapTimesList.appendChild(item));
                            updateLapDisplay(); statusMessage.textContent = `Loaded session: "${sessionNameInput.value}"`; statusMessage.className = "status-message status-info"; alert(`Session "${sessionNameInput.value}" loaded.`);
                        } else { alert("No valid session data found in cookie."); }
                    } catch (e) { console.error("Error parsing session cookie:", e); alert("Error loading session from cookie."); }
                    return; } }
             alert("No saved session found.");
        });

        // --- START ---
        init();

    </script>
</body>
</html>