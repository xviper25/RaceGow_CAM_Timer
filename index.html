<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Racegow FPV Lap Timer</title>
    <style>
        :root {
            --primary-color: #007bff; /* Racegow Blue (example) */
            --secondary-color: #6c757d;
            --background-color: #f0f2f5;
            --surface-color: #ffffff;
            --text-color: #333;
            --success-color: #28a745;
            --warning-color: #ffc107;
            --danger-color: #dc3545;
            --font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            --line-thickness: 10px; /* Thickness of draggable lines */
            --line-color-idle: rgba(220, 53, 69, 0.6); /* Bootstrap danger, semi-transparent */
            --line-color-active: rgba(220, 53, 69, 0.9); 
        }

        body {
            font-family: var(--font-family);
            margin: 0;
            padding: 0;
            background-color: var(--background-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            overscroll-behavior: none; 
        }

        .container {
            width: 100%;
            max-width: 600px;
            padding: 15px;
            box-sizing: border-box;
        }

        header {
            background-color: var(--primary-color);
            color: white;
            padding: 15px;
            text-align: center;
            font-size: 1.5em;
            font-weight: bold;
            width: 100%;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 15px;
        }
        header h1 {
            margin: 0;
            font-size: 1.2em;
        }

        .video-container {
            position: relative;
            width: 100%;
            background-color: #000;
            border-radius: 8px;
            overflow: hidden; /* Important for line positioning */
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }

        #videoFeed {
            width: 100%;
            display: block;
            transform: scaleX(-1); /* Mirror front camera */
        }

        #detectionCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Canvas is for display only now */
        }

        .boundary-line {
            position: absolute;
            background-color: var(--line-color-idle);
            z-index: 5;
            touch-action: none; /* Crucial for preventing scroll on drag */
            box-sizing: border-box;
            /* border: 1px dashed rgba(255,255,255,0.3); Add border for better visibility if needed */
        }
        #lineTop, #lineBottom {
            height: var(--line-thickness);
            cursor: ns-resize;
        }
        #lineLeft, #lineRight {
            width: var(--line-thickness);
            cursor: ew-resize;
        }


        .controls, .session-controls, .stats-display, .lap-list-container {
            background-color: var(--surface-color);
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .controls h2, .session-controls h2, .stats-display h2, .lap-list-container h2 {
            margin-top: 0;
            font-size: 1.2em;
            color: var(--primary-color);
            border-bottom: 1px solid #eee;
            padding-bottom: 8px;
        }

        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 10px 15px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.2s ease;
        }
        button:hover {
            background-color: #0056b3;
        }
        button:disabled {
            background-color: var(--secondary-color);
            cursor: not-allowed;
        }
        .btn-success { background-color: var(--success-color); }
        .btn-success:hover { background-color: #1e7e34; }
        .btn-warning { background-color: var(--warning-color); color: #333; }
        .btn-warning:hover { background-color: #d39e00; }
        .btn-danger { background-color: var(--danger-color); }
        .btn-danger:hover { background-color: #bd2130; }


        input[type="text"], input[type="range"] {
            padding: 8px;
            margin: 5px 0;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box;
            width: calc(100% - 10px);
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        .slider-container label {
            margin-right: 10px;
            white-space: nowrap;
        }
        .slider-container input[type="range"] {
            flex-grow: 1;
        }
        .slider-container span {
            min-width: 30px;
            text-align: right;
        }


        #lapTimesList {
            list-style-type: none;
            padding: 0;
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #eee;
            border-radius: 4px;
        }
        #lapTimesList li {
            padding: 8px 10px;
            border-bottom: 1px solid #eee;
        }
        #lapTimesList li:last-child {
            border-bottom: none;
        }
        #lapTimesList li.best-lap {
            background-color: #e6ffed;
            font-weight: bold;
        }

        .status-message {
            padding: 10px;
            margin-bottom: 15px;
            border-radius: 5px;
            text-align: center;
        }
        .status-info { background-color: #e7f3fe; color: #0c5460; border: 1px solid #b8daff;}
        .status-error { background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6cb;}
        .status-warning { background-color: #fff3cd; color: #856404; border: 1px solid #ffeeba; }


        .flex-controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-around;
        }
        .flex-controls button {
            flex-grow: 1;
            margin: 5px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            text-align: center;
        }
        .stat-item {
            background-color: #f9f9f9;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #eee;
        }
        .stat-item .label {
            font-size: 0.8em;
            color: var(--secondary-color);
            display: block;
            margin-bottom: 5px;
        }
        .stat-item .value {
            font-size: 1.4em;
            font-weight: bold;
            color: var(--primary-color);
        }
        .stat-item .value.small {
            font-size: 1em;
        }

        #instructionOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
            font-size: 1.2em;
            z-index: 10;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <header>
        <h1>Racegow FPV Lap Timer</h1>
    </header>

    <div class="container">
        <div id="statusMessage" class="status-message status-info">Initializing...</div>

        <div class="video-container">
            <video id="videoFeed" playsinline autoplay muted></video>
            <canvas id="detectionCanvas"></canvas>
            <!-- Draggable Boundary Lines -->
            <div class="boundary-line" id="lineTop"></div>
            <div class="boundary-line" id="lineBottom"></div>
            <div class="boundary-line" id="lineLeft"></div>
            <div class="boundary-line" id="lineRight"></div>
            <div id="instructionOverlay" style="display: none;">Adjust boundary lines to set detection zone.</div>
        </div>

        <div class="controls">
            <h2>Timer Controls</h2>
            <div class="flex-controls">
                <button id="startTimerBtn" class="btn-success">Start Timer</button>
                <button id="stopTimerBtn" disabled class="btn-danger">Stop Timer</button>
                <button id="resetTimerBtn" class="btn-warning">Reset All</button>
            </div>
            <div class="slider-container">
                <label for="sensitivityRange">Sensitivity:</label>
                <input type="range" id="sensitivityRange" min="5" max="50" value="20">
                <span id="sensitivityValue">20</span>
            </div>
            <div class="slider-container">
                <label for="minLapTimeRange">Min Lap (s):</label>
                <input type="range" id="minLapTimeRange" min="0.5" max="5" step="0.1" value="1.0">
                <span id="minLapTimeValue">1.0</span>
            </div>
        </div>

        <div class="stats-display">
            <h2>Live Stats</h2>
            <div class="stats-grid">
                <div class="stat-item">
                    <span class="label">Current Lap</span>
                    <span class="value" id="lapCount">0</span>
                </div>
                <div class="stat-item">
                    <span class="label">Last Lap</span>
                    <span class="value" id="lastLapTime">0.000s</span>
                </div>
                <div class="stat-item">
                    <span class="label">Best Lap</span>
                    <span class="value" id="bestLapTime">N/A</span>
                </div>
            </div>
             <div class="stat-item" style="margin-top:10px;">
                <span class="label">Best 3 Consecutive</span>
                <span class="value small" id="best3Consecutive">-</span>
            </div>
            <div class="stat-item">
                <span class="label">Total Time</span>
                <span class="value" id="totalTime">0.000s</span>
            </div>
        </div>

        <div class="lap-list-container">
            <h2>Lap Times</h2>
            <ul id="lapTimesList"></ul>
        </div>

        <div class="session-controls">
            <h2>Session Management</h2>
            <input type="text" id="sessionName" placeholder="Enter session name (e.g., Track A - Evening)">
            <button id="saveSessionBtn">Save Laps</button>
            <button id="loadSessionBtn">Load Last Session</button>
            <p style="font-size: 0.8em; color: var(--secondary-color);">Sessions are saved in your browser's cookies.</p>
        </div>
    </div>

    <script>
        const video = document.getElementById('videoFeed');
        const videoContainer = document.querySelector('.video-container');
        const canvas = document.getElementById('detectionCanvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const instructionOverlay = document.getElementById('instructionOverlay');

        const lineTop = document.getElementById('lineTop');
        const lineBottom = document.getElementById('lineBottom');
        const lineLeft = document.getElementById('lineLeft');
        const lineRight = document.getElementById('lineRight');
        const boundaryLines = [lineTop, lineBottom, lineLeft, lineRight];

        const startTimerBtn = document.getElementById('startTimerBtn');
        const stopTimerBtn = document.getElementById('stopTimerBtn');
        const resetTimerBtn = document.getElementById('resetTimerBtn');
        
        const sensitivityRange = document.getElementById('sensitivityRange');
        const sensitivityValue = document.getElementById('sensitivityValue');
        const minLapTimeRange = document.getElementById('minLapTimeRange');
        const minLapTimeValue = document.getElementById('minLapTimeValue');

        const lapCountDisplay = document.getElementById('lapCount');
        const lastLapTimeDisplay = document.getElementById('lastLapTime');
        const bestLapTimeDisplay = document.getElementById('bestLapTime');
        const totalTimeDisplay = document.getElementById('totalTime');
        const best3ConsecutiveDisplay = document.getElementById('best3Consecutive');
        const lapTimesList = document.getElementById('lapTimesList');
        const sessionNameInput = document.getElementById('sessionName');
        const saveSessionBtn = document.getElementById('saveSessionBtn');
        const loadSessionBtn = document.getElementById('loadSessionBtn');
        const statusMessage = document.getElementById('statusMessage');

        let stream;
        let detectionZone = null; 
        let activeLine = null;
        let touchStartOffsetX, touchStartOffsetY; // Offset within the line element
        let initialLineRect = {}; // To store line's original rect on touch start

        let timerRunning = false;
        let lapStartTime = 0;
        let currentLap = 0;
        let lapTimes = [];
        let lastTriggerTime = 0;
        let animationFrameId;
        let prevImageData = null;
        let totalStartTime = 0;

        const MOTION_THRESHOLD_BASE = 20;
        let MIN_LAP_TIME_MS = 1000;
        const MIN_ZONE_DIMENSION = 20; // Minimum width/height for detection zone in pixels
        const LINE_THICKNESS = 10; // Must match CSS --line-thickness

        async function init() {
            try {
                statusMessage.textContent = "Requesting camera access...";
                statusMessage.className = "status-message status-info";
                stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' } });
                video.srcObject = stream;
                await video.play();

                video.onloadedmetadata = () => {
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    
                    loadDetectionZoneFromCookie(); // Try to load zone
                    if (!detectionZone) { // If no zone loaded or invalid, create default
                        const inset = 0.15; // 15% inset
                        detectionZone = {
                            x: canvas.width * inset,
                            y: canvas.height * inset,
                            width: canvas.width * (1 - 2 * inset),
                            height: canvas.height * (1 - 2 * inset)
                        };
                    }
                    
                    initializeBoundaryLines();
                    positionLinesFromZone(); // Position draggable lines
                    drawDetectionZone(); // Draw green rectangle
                    
                    statusMessage.textContent = "Camera active. Adjust zone if needed.";
                    instructionOverlay.style.display = 'flex';
                    setTimeout(() => instructionOverlay.style.display = 'none', 3000); // Hide after 3s
                };
            } catch (err) {
                console.error("Error accessing camera:", err);
                statusMessage.textContent = `Error: ${err.name}. Ensure camera access is allowed.`;
                statusMessage.className = "status-message status-error";
                startTimerBtn.disabled = true;
            }
        }

        function initializeBoundaryLines() {
            boundaryLines.forEach(line => {
                line.addEventListener('touchstart', handleTouchStart, { passive: false });
            });
            // Add move and end listeners to the container to catch drags outside the line itself
            videoContainer.addEventListener('touchmove', handleTouchMove, { passive: false });
            videoContainer.addEventListener('touchend', handleTouchEnd);
            videoContainer.addEventListener('touchcancel', handleTouchEnd); // Also handle cancel
        }
        
        function scaleTouchToCanvas(touchX, touchY) {
            const videoRect = videoContainer.getBoundingClientRect(); // Use videoContainer for consistency
            return {
                x: (touchX - videoRect.left) * (canvas.width / videoRect.width),
                y: (touchY - videoRect.top) * (canvas.height / videoRect.height)
            };
        }

        function handleTouchStart(event) {
            if (timerRunning) return;
            event.preventDefault(); // Prevent scrolling
            
            activeLine = event.target;
            activeLine.style.backgroundColor = 'var(--line-color-active)';

            const touch = event.touches[0];
            const scaledTouch = scaleTouchToCanvas(touch.clientX, touch.clientY);
            
            // Store initial rect of the line being dragged (in canvas coordinates)
            initialLineRect = {
                top: parseFloat(activeLine.style.top) || 0,
                left: parseFloat(activeLine.style.left) || 0,
                width: parseFloat(activeLine.style.width) || 0,
                height: parseFloat(activeLine.style.height) || 0
            };
            // Store offset of touch from the line's origin, helps keep drag smooth
            touchStartOffsetX = scaledTouch.x - initialLineRect.left;
            touchStartOffsetY = scaledTouch.y - initialLineRect.top;
            
            instructionOverlay.style.display = 'none';
        }

        function handleTouchMove(event) {
            if (!activeLine || timerRunning) return;
            event.preventDefault();

            const touch = event.touches[0];
            const scaledTouch = scaleTouchToCanvas(touch.clientX, touch.clientY);

            let newX = detectionZone.x;
            let newY = detectionZone.y;
            let newWidth = detectionZone.width;
            let newHeight = detectionZone.height;

            if (activeLine === lineTop) {
                newY = Math.max(0, Math.min(scaledTouch.y - touchStartOffsetY, detectionZone.y + detectionZone.height - LINE_THICKNESS - MIN_ZONE_DIMENSION));
                newHeight = (detectionZone.y + detectionZone.height) - newY;
            } else if (activeLine === lineBottom) {
                const bottomEdge = Math.min(canvas.height - LINE_THICKNESS, Math.max(scaledTouch.y - touchStartOffsetY, detectionZone.y + MIN_ZONE_DIMENSION));
                newHeight = bottomEdge - detectionZone.y;
            } else if (activeLine === lineLeft) {
                newX = Math.max(0, Math.min(scaledTouch.x - touchStartOffsetX, detectionZone.x + detectionZone.width - LINE_THICKNESS - MIN_ZONE_DIMENSION));
                newWidth = (detectionZone.x + detectionZone.width) - newX;
            } else if (activeLine === lineRight) {
                const rightEdge = Math.min(canvas.width - LINE_THICKNESS, Math.max(scaledTouch.x - touchStartOffsetX, detectionZone.x + MIN_ZONE_DIMENSION));
                newWidth = rightEdge - detectionZone.x;
            }
            
            // Update detectionZone ensuring minimum dimensions
            if (newWidth >= MIN_ZONE_DIMENSION) {
                detectionZone.x = newX;
                detectionZone.width = newWidth;
            }
            if (newHeight >= MIN_ZONE_DIMENSION) {
                detectionZone.y = newY;
                detectionZone.height = newHeight;
            }

            positionLinesFromZone();
            drawDetectionZone();
        }

        function handleTouchEnd(event) {
            if (!activeLine || timerRunning) return;
            activeLine.style.backgroundColor = 'var(--line-color-idle)';
            activeLine = null;
            saveDetectionZoneToCookie();
            statusMessage.textContent = "Detection zone updated. Ready.";
            statusMessage.className = "status-message status-info";
        }
        
        function positionLinesFromZone() {
            if (!detectionZone || !lineTop) return; // Elements might not be ready

            // Top line
            lineTop.style.top = detectionZone.y + 'px';
            lineTop.style.left = detectionZone.x + 'px';
            lineTop.style.width = detectionZone.width + 'px';

            // Bottom line: its top edge is (zone.y + zone.height - thickness)
            lineBottom.style.top = (detectionZone.y + detectionZone.height - LINE_THICKNESS) + 'px';
            lineBottom.style.left = detectionZone.x + 'px';
            lineBottom.style.width = detectionZone.width + 'px';

            // Left line
            lineLeft.style.left = detectionZone.x + 'px';
            lineLeft.style.top = detectionZone.y + 'px';
            lineLeft.style.height = detectionZone.height + 'px';

            // Right line: its left edge is (zone.x + zone.width - thickness)
            lineRight.style.left = (detectionZone.x + detectionZone.width - LINE_THICKNESS) + 'px';
            lineRight.style.top = detectionZone.y + 'px';
            lineRight.style.height = detectionZone.height + 'px';
        }


        function drawDetectionZone() {
            clearCanvas();
            if (detectionZone) {
                ctx.strokeStyle = 'rgba(0, 255, 0, 0.8)';
                ctx.lineWidth = 3; // Line width for the green rectangle
                ctx.strokeRect(detectionZone.x, detectionZone.y, detectionZone.width, detectionZone.height);
            }
        }
        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        // --- Motion Detection (largely unchanged) ---
        function detectMotion() {
            if (!timerRunning || !detectionZone || !video.videoWidth) {
                if(timerRunning) animationFrameId = requestAnimationFrame(detectMotion);
                return;
            }
            const offscreenCanvas = document.createElement('canvas');
            const offscreenCtx = offscreenCanvas.getContext('2d', { willReadFrequently: true });
            offscreenCanvas.width = Math.max(1, Math.floor(detectionZone.width)); // Ensure positive dims
            offscreenCanvas.height = Math.max(1, Math.floor(detectionZone.height));

            const sourceX = video.videoWidth - detectionZone.x - detectionZone.width;
            offscreenCtx.drawImage(video, 
                                   sourceX, detectionZone.y, detectionZone.width, detectionZone.height,
                                   0, 0, offscreenCanvas.width, offscreenCanvas.height); // Draw to offscreen canvas
            
            const currentFrameData = offscreenCtx.getImageData(0, 0, offscreenCanvas.width, offscreenCanvas.height);
            
            if (prevImageData) {
                let diff = 0;
                for (let i = 0; i < currentFrameData.data.length; i += 4) {
                    diff += Math.abs(currentFrameData.data[i] - prevImageData.data[i]);
                    diff += Math.abs(currentFrameData.data[i+1] - prevImageData.data[i+1]);
                    diff += Math.abs(currentFrameData.data[i+2] - prevImageData.data[i+2]);
                }
                const avgDiff = diff / (currentFrameData.data.length / 4);
                const motionThreshold = MOTION_THRESHOLD_BASE * ( (55 - parseInt(sensitivityRange.value)) / 30 );

                if (avgDiff > motionThreshold) {
                    triggerLap();
                    ctx.fillStyle = 'rgba(255, 255, 0, 0.5)';
                    ctx.fillRect(detectionZone.x, detectionZone.y, detectionZone.width, detectionZone.height);
                    setTimeout(() => drawDetectionZone(), 100);
                }
            }
            prevImageData = currentFrameData;
            animationFrameId = requestAnimationFrame(detectMotion);
        }

        // --- Timer Logic (largely unchanged) ---
        startTimerBtn.addEventListener('click', () => {
            if (!detectionZone || detectionZone.width < MIN_ZONE_DIMENSION || detectionZone.height < MIN_ZONE_DIMENSION) {
                statusMessage.textContent = "Please set a valid detection zone first!";
                statusMessage.className = "status-message status-warning";
                instructionOverlay.style.display = 'flex';
                return;
            }
            if (timerRunning) return;

            timerRunning = true;
            startTimerBtn.disabled = true;
            stopTimerBtn.disabled = false;
            resetTimerBtn.disabled = true;
            sensitivityRange.disabled = true;
            minLapTimeRange.disabled = true;
            boundaryLines.forEach(line => line.style.pointerEvents = 'none'); // Disable line dragging

            lapStartTime = performance.now();
            if (currentLap === 0) {
                totalStartTime = lapStartTime;
            }
            lastTriggerTime = performance.now() - MIN_LAP_TIME_MS;
            
            statusMessage.textContent = "Timer started. Listening for motion...";
            statusMessage.className = "status-message status-info";
            
            prevImageData = null;
            detectMotion();
            updateTotalTimeDisplay();
        });

        stopTimerBtn.addEventListener('click', () => {
            if (!timerRunning) return;
            timerRunning = false;
            cancelAnimationFrame(animationFrameId);
            startTimerBtn.disabled = false;
            stopTimerBtn.disabled = true;
            resetTimerBtn.disabled = false;
            sensitivityRange.disabled = false;
            minLapTimeRange.disabled = false;
            boundaryLines.forEach(line => line.style.pointerEvents = 'auto'); // Re-enable line dragging
            prevImageData = null;
            statusMessage.textContent = "Timer stopped. Adjust zone or start again.";
            statusMessage.className = "status-message status-info";
        });

        resetTimerBtn.addEventListener('click', () => {
            if (timerRunning) stopTimerBtn.click(); 
            currentLap = 0;
            lapTimes = [];
            lapStartTime = 0;
            totalStartTime = 0;
            prevImageData = null;
            updateLapDisplay();
            lapTimesList.innerHTML = '';
            bestLapTimeDisplay.textContent = "N/A";
            best3ConsecutiveDisplay.textContent = "-";
            totalTimeDisplay.textContent = "0.000s";
            lapCountDisplay.textContent = "0";
            lastLapTimeDisplay.textContent = "0.000s";
            sessionNameInput.value = '';
            
            // Reset detection zone to default and reposition lines
            const inset = 0.15;
            detectionZone = {
                x: canvas.width * inset,
                y: canvas.height * inset,
                width: canvas.width * (1 - 2 * inset),
                height: canvas.height * (1 - 2 * inset)
            };
            positionLinesFromZone();
            drawDetectionZone();
            saveDetectionZoneToCookie(); // Save the reset zone

            statusMessage.textContent = "Timer reset. Adjust zone and start.";
            statusMessage.className = "status-message status-info";
            instructionOverlay.style.display = 'flex';
            setTimeout(() => instructionOverlay.style.display = 'none', 3000);
        });

        function triggerLap() {
            const now = performance.now();
            if (now - lastTriggerTime < MIN_LAP_TIME_MS) {
                return;
            }
            lastTriggerTime = now;

            if (currentLap > 0 || lapTimes.length > 0) {
                 const lapTime = (now - lapStartTime) / 1000;
                 lapTimes.push(lapTime);
            } else if (currentLap === 0 && lapTimes.length === 0) {
                 totalStartTime = now;
            }
            currentLap++;
            lapStartTime = now;
            updateLapDisplay();
            speakLapTime();
        }

        function updateTotalTimeDisplay() {
            if (timerRunning) {
                const elapsed = (performance.now() - totalStartTime) / 1000;
                totalTimeDisplay.textContent = elapsed.toFixed(3) + 's';
                requestAnimationFrame(updateTotalTimeDisplay);
            } else if (lapTimes.length > 0) {
                 const sumOfLaps = lapTimes.reduce((sum, t) => sum + t, 0);
                 totalTimeDisplay.textContent = sumOfLaps.toFixed(3) + 's';
            } else {
                totalTimeDisplay.textContent = "0.000s";
            }
        }

        function updateLapDisplay() {
            lapCountDisplay.textContent = currentLap;
            if (lapTimes.length > 0) {
                const lastLap = lapTimes[lapTimes.length - 1];
                lastLapTimeDisplay.textContent = lastLap.toFixed(3) + 's';

                const li = document.createElement('li');
                li.textContent = `Lap ${lapTimes.length}: ${lastLap.toFixed(3)}s`;
                lapTimesList.prepend(li);

                updateBestLap();
                updateBest3Consecutive();
            } else {
                lastLapTimeDisplay.textContent = "0.000s";
            }
            updateTotalTimeDisplay();
        }

        function updateBestLap() {
            if (lapTimes.length === 0) {
                bestLapTimeDisplay.textContent = "N/A";
                return;
            }
            const best = Math.min(...lapTimes);
            bestLapTimeDisplay.textContent = best.toFixed(3) + 's';
            const lis = lapTimesList.getElementsByTagName('li');
            for (let li of lis) {
                li.classList.remove('best-lap');
                if (parseFloat(li.textContent.split(': ')[1]) === best) {
                    li.classList.add('best-lap');
                }
            }
        }

        function updateBest3Consecutive() {
            if (lapTimes.length < 3) {
                best3ConsecutiveDisplay.textContent = "-";
                return;
            }
            let minSum = Infinity;
            let bestStartIndex = -1;
            for (let i = 0; i <= lapTimes.length - 3; i++) {
                const currentSum = lapTimes[i] + lapTimes[i+1] + lapTimes[i+2];
                if (currentSum < minSum) {
                    minSum = currentSum;
                    bestStartIndex = i;
                }
            }
            if (bestStartIndex !== -1) {
                const laps = lapTimes.slice(bestStartIndex, bestStartIndex + 3);
                best3ConsecutiveDisplay.textContent = 
                    `Laps ${bestStartIndex + 1}-${bestStartIndex + 3}: ${minSum.toFixed(3)}s ` +
                    `(${laps.map(t => t.toFixed(2)).join(', ')})`;
            } else {
                 best3ConsecutiveDisplay.textContent = "-";
            }
        }

        function speakLapTime() {
            if (lapTimes.length > 0 && 'speechSynthesis' in window) {
                const lastLap = lapTimes[lapTimes.length - 1];
                const timeStr = lastLap.toFixed(2).replace('.', ' point ');
                const utterance = new SpeechSynthesisUtterance(`Lap ${lapTimes.length}. ${timeStr} seconds.`);
                speechSynthesis.speak(utterance);
            }
        }

        sensitivityRange.addEventListener('input', (e) => {
            sensitivityValue.textContent = e.target.value;
        });
        minLapTimeRange.addEventListener('input', (e) => {
            minLapTimeValue.textContent = parseFloat(e.target.value).toFixed(1);
            MIN_LAP_TIME_MS = parseFloat(e.target.value) * 1000;
        });
        MIN_LAP_TIME_MS = parseFloat(minLapTimeRange.value) * 1000;
        minLapTimeValue.textContent = parseFloat(minLapTimeRange.value).toFixed(1);
        sensitivityValue.textContent = sensitivityRange.value;

        function saveDetectionZoneToCookie() {
            if (detectionZone) {
                document.cookie = `racegow_detectionZone=${JSON.stringify(detectionZone)};max-age=31536000;path=/;samesite=Lax`;
            }
        }
        function loadDetectionZoneFromCookie() {
            const cookies = document.cookie.split(';');
            for (let cookie of cookies) {
                const [name, value] = cookie.trim().split('=');
                if (name === 'racegow_detectionZone') {
                    try {
                        const parsedZone = JSON.parse(value);
                        // Basic validation for the loaded zone
                        if (parsedZone && typeof parsedZone.x === 'number' && typeof parsedZone.y === 'number' &&
                            typeof parsedZone.width === 'number' && parsedZone.width >= MIN_ZONE_DIMENSION &&
                            typeof parsedZone.height === 'number' && parsedZone.height >= MIN_ZONE_DIMENSION) {
                            detectionZone = parsedZone;
                            console.log("Loaded detection zone from cookie:", detectionZone);
                        } else {
                            console.warn("Invalid detection zone data in cookie.");
                            detectionZone = null;
                        }
                    } catch (e) {
                        console.error("Error parsing detection zone from cookie:", e);
                        detectionZone = null;
                    }
                    return;
                }
            }
        }

        saveSessionBtn.addEventListener('click', () => {
            const sessionName = sessionNameInput.value.trim() || `Session ${new Date().toLocaleString()}`;
            if (lapTimes.length === 0) {
                alert("No laps to save!");
                return;
            }
            const sessionData = {
                name: sessionName,
                laps: lapTimes,
                date: new Date().toISOString()
            };
            document.cookie = `racegow_lastSession=${JSON.stringify(sessionData)};max-age=31536000;path=/;samesite=Lax`;
            alert(`Session "${sessionName}" saved!`);
        });

        loadSessionBtn.addEventListener('click', () => {
            const cookies = document.cookie.split(';');
            for (let cookie of cookies) {
                const [name, value] = cookie.trim().split('=');
                if (name === 'racegow_lastSession') {
                    try {
                        const sessionData = JSON.parse(value);
                        if (sessionData && sessionData.laps) {
                            if (timerRunning) stopTimerBtn.click();
                            lapTimes = sessionData.laps;
                            sessionNameInput.value = sessionData.name || "Loaded Session";
                            currentLap = lapTimes.length;

                            lapTimesList.innerHTML = '';
                            lapTimes.forEach((lapTime, index) => {
                                const li = document.createElement('li');
                                li.textContent = `Lap ${index + 1}: ${lapTime.toFixed(3)}s`;
                                lapTimesList.prepend(li);
                            });
                            const items = Array.from(lapTimesList.childNodes);
                            items.reverse().forEach(item => lapTimesList.appendChild(item));

                            updateLapDisplay();
                            statusMessage.textContent = `Loaded session: "${sessionNameInput.value}"`;
                            statusMessage.className = "status-message status-info";
                            alert(`Session "${sessionNameInput.value}" loaded.`);
                        } else {
                             alert("No valid session data found in cookie.");
                        }
                    } catch (e) {
                        console.error("Error parsing session from cookie:", e);
                        alert("Error loading session from cookie.");
                    }
                    return;
                }
            }
            alert("No saved session found.");
        });

        init();
    </script>
</body>
</html>